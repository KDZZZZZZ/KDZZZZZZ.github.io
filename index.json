[{"content":"Welcome! Hello everyone! This is my new blog built with Hugo. I\u0026rsquo;m excited to share my thoughts and experiences here.\nWhat to Expect In this blog, I plan to write about:\nTechnology and Programming Learning experiences Personal growth Interesting projects Why I Started Blogging I believe writing is a great way to:\nOrganize thoughts Share knowledge Document learning journey Connect with like-minded people Stay tuned for more posts!\n","permalink":"https://KDZZZZZZ.github.io/posts/welcome-to-my-blog/","summary":"\u003ch2 id=\"welcome\"\u003eWelcome!\u003c/h2\u003e\n\u003cp\u003eHello everyone! This is my new blog built with Hugo. I\u0026rsquo;m excited to share my thoughts and experiences here.\u003c/p\u003e\n\u003ch3 id=\"what-to-expect\"\u003eWhat to Expect\u003c/h3\u003e\n\u003cp\u003eIn this blog, I plan to write about:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTechnology and Programming\u003c/li\u003e\n\u003cli\u003eLearning experiences\u003c/li\u003e\n\u003cli\u003ePersonal growth\u003c/li\u003e\n\u003cli\u003eInteresting projects\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"why-i-started-blogging\"\u003eWhy I Started Blogging\u003c/h3\u003e\n\u003cp\u003eI believe writing is a great way to:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOrganize thoughts\u003c/li\u003e\n\u003cli\u003eShare knowledge\u003c/li\u003e\n\u003cli\u003eDocument learning journey\u003c/li\u003e\n\u003cli\u003eConnect with like-minded people\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned for more posts!\u003c/p\u003e","title":"Welcome to My Blog"},{"content":"欢迎来到我的博客！ 这是我用 Hugo 搭建的新博客的第一篇文章。我很高兴能在这里开始分享我的想法和经历。\n期待 我会在这里写一些我感兴趣的话题。敬请期待更多内容！\n","permalink":"https://KDZZZZZZ.github.io/posts/my-first-post/","summary":"\u003ch1 id=\"欢迎来到我的博客\"\u003e欢迎来到我的博客！\u003c/h1\u003e\n\u003cp\u003e这是我用 Hugo 搭建的新博客的第一篇文章。我很高兴能在这里开始分享我的想法和经历。\u003c/p\u003e\n\u003ch2 id=\"期待\"\u003e期待\u003c/h2\u003e\n\u003cp\u003e我会在这里写一些我感兴趣的话题。敬请期待更多内容！\u003c/p\u003e","title":"我的第一篇博客"},{"content":"Oops，本科就读于杭州电子科技大学CS系28级，渴望灵感之风的吹拂也希望夯实工程能力。\n虚度的时间 探索了CS的必修四件套，go后端入门，NLP算法基础，以及一些电子元件的理论知识。还有一些比赛、外包项目。\n痛定思痛 接下来我将继续MLSys方向，同时分享一些ML和DL算法和论文复现。或许还有一些微调RAG提示词工程的笔记。靡不有初，鲜克有终。\n关于博客 理论会尽力严谨，如果有教程会尽力细致，如果有随笔会尽量随便。\nGitHub: KDZZZZZZ Email: QQ邮箱 bilibili: 在B站考研 会赢的，对吧\n","permalink":"https://KDZZZZZZ.github.io/about/","summary":"\u003cp\u003eOops，本科就读于杭州电子科技大学CS系28级，渴望灵感之风的吹拂也希望夯实工程能力。\u003c/p\u003e\n\u003ch2 id=\"虚度的时间\"\u003e虚度的时间\u003c/h2\u003e\n\u003cp\u003e探索了CS的必修四件套，go后端入门，NLP算法基础，以及一些电子元件的理论知识。还有一些比赛、外包项目。\u003c/p\u003e\n\u003ch2 id=\"痛定思痛\"\u003e痛定思痛\u003c/h2\u003e\n\u003cp\u003e接下来我将继续MLSys方向，同时分享一些ML和DL算法和论文复现。或许还有一些微调RAG提示词工程的笔记。靡不有初，鲜克有终。\u003c/p\u003e\n\u003ch2 id=\"关于博客\"\u003e关于博客\u003c/h2\u003e\n\u003cp\u003e理论会尽力严谨，如果有教程会尽力细致，如果有随笔会尽量随便。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub: \u003ca href=\"https://github.com/KDZZZZZZ\"\u003eKDZZZZZZ\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eEmail: \u003ca href=\"mailto:2112335382@qq.com\"\u003eQQ邮箱\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ebilibili: \u003ca href=\"https://space.bilibili.com/1938413314?spm_id_from=333.1007.0.0\"\u003e在B站考研\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e会赢的，对吧\u003c/p\u003e","title":"About Me"},{"content":"Hello, World! This is my first blog post. Here, I\u0026rsquo;ll share some interesting tech insights and life experiences.\nWhy Start a Blog? Blogging helps me:\nDocument my learning journey Share technical insights Connect with like-minded people Future Plans I plan to write about:\nProgramming techniques Learning experiences Life reflections Stay tuned!\n","permalink":"https://KDZZZZZZ.github.io/posts/hello-world/","summary":"\u003ch2 id=\"hello-world\"\u003eHello, World!\u003c/h2\u003e\n\u003cp\u003eThis is my first blog post. Here, I\u0026rsquo;ll share some interesting tech insights and life experiences.\u003c/p\u003e\n\u003ch3 id=\"why-start-a-blog\"\u003eWhy Start a Blog?\u003c/h3\u003e\n\u003cp\u003eBlogging helps me:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDocument my learning journey\u003c/li\u003e\n\u003cli\u003eShare technical insights\u003c/li\u003e\n\u003cli\u003eConnect with like-minded people\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"future-plans\"\u003eFuture Plans\u003c/h3\u003e\n\u003cp\u003eI plan to write about:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProgramming techniques\u003c/li\u003e\n\u003cli\u003eLearning experiences\u003c/li\u003e\n\u003cli\u003eLife reflections\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned!\u003c/p\u003e","title":"Hello World"},{"content":"首先给出TVM中注册自定义函数和调用自定义函数的方法\n// 注册函数 TVM_REGISTER_GLOBAL(\u0026#34;add\u0026#34;).set_body([](TVMArgs args, TVMRetValue* ret) { int a = args[0]; int b = args[1]; *ret = a + b; }); // 调用函数 PackedFunc add = runtime::Registry::Get(\u0026#34;add\u0026#34;); int result = add(3, 5); // 返回 8 TVM实现注册Lambda函数的set_body函数是一个指向PackedFunc类型的指针.\nTVM_REGISTER_GLOBAL的实现如下：\n#define REGISTER_GLOBAL(name, func) \\ tvm::runtime::FRegistry::Register(name, tvm::runtime::PackedFunc(func)) 使用全局哈希表FRegistry注册函数。通过宏REGISTER_GLOBAL(\u0026quot;func_name\u0026quot;, MyFunction)将函数与名称绑定，后续通过GetPackedFunc(\u0026quot;func_name\u0026quot;)查找.\n使用REGISTER_GLOBAL宏将函数与名称绑定。这个宏会调用FRegistry::Register方法，将函数存储到全局哈希表中。\nPackedFunc类型继承自ObjectRef基类，实现了运算符重载，又用make_object函数创建一个PackedFuncSubObj类型对象，这个对象可以储存可调用对象.\nPackedFuncSubObj继承自PackedFuncObj, 这是Object的子类，Object实现了引用计数和类型检查，PackedFunObj对函数指针、参数和返回值指针进行了打包。\nPackedFuncSubObj类型用std::remove_reference和std::remove_cv进行了类型擦除，对const、volatile和引用进行去壳，移除我们不需要的特性.\nPackedFuncSubObj中定义了Extractor提取器结构，提取器内部的Call函数是一个指针，用来调用可调用对象。\n接下来解释一下参数和返回值的数据结构。\n分别是TVMArgs和TVMRetValue,都使用了联合体TVMValue对数据进行打包并进行了运算符重载和用于数据传递的基本方法。\n以上所有的实现基本都在include/tvm/runtime/packed_func.h、include/tvm/runtime/registry.h和src/runtime/registry.cc\nPython封装了ctypes库，能够通过name查找全局注册的C++函数并获得函数句柄，调用后得到传回的返回值。 其中对数据类型的包装也是TVM实现任意语言互相调用的关键。\n","permalink":"https://KDZZZZZZ.github.io/posts/tvm%E4%BB%A3%E7%A0%81%E5%BA%93%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/","summary":"\u003cp\u003e首先给出TVM中注册自定义函数和调用自定义函数的方法\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 注册函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eTVM_REGISTER_GLOBAL(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;add\u0026#34;\u003c/span\u003e).set_body([](TVMArgs args, TVMRetValue\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ret) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e args[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e b \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e args[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eret \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 调用函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003ePackedFunc add \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e runtime\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eRegistry\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eGet(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;add\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e add(\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// 返回 8\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTVM实现注册Lambda函数的\u003ccode\u003eset_body\u003c/code\u003e函数是一个指向\u003ccode\u003ePackedFunc\u003c/code\u003e类型的指针.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTVM_REGISTER_GLOBAL\u003c/code\u003e的实现如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define REGISTER_GLOBAL(name, func) \\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e  tvm::runtime::FRegistry::Register(name, tvm::runtime::PackedFunc(func))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用全局哈希表\u003ccode\u003eFRegistry\u003c/code\u003e注册函数。通过宏\u003ccode\u003eREGISTER_GLOBAL(\u0026quot;func_name\u0026quot;, MyFunction)\u003c/code\u003e将函数与名称绑定，后续通过\u003ccode\u003eGetPackedFunc(\u0026quot;func_name\u0026quot;)\u003c/code\u003e查找.\u003c/p\u003e\n\u003cp\u003e使用\u003ccode\u003eREGISTER_GLOBAL\u003c/code\u003e宏将函数与名称绑定。这个宏会调用\u003ccode\u003eFRegistry::Register\u003c/code\u003e方法，将函数存储到全局哈希表中。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFunc\u003c/code\u003e类型继承自\u003ccode\u003eObjectRef\u003c/code\u003e基类，实现了运算符重载，又用\u003ccode\u003emake_object\u003c/code\u003e函数创建一个\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e类型对象，这个对象可以储存可调用对象.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e继承自\u003ccode\u003ePackedFuncObj\u003c/code\u003e, 这是\u003ccode\u003eObject\u003c/code\u003e的子类，\u003ccode\u003eObject\u003c/code\u003e实现了引用计数和类型检查，\u003ccode\u003ePackedFunObj\u003c/code\u003e对函数指针、参数和返回值指针进行了打包。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e类型用\u003ccode\u003estd::remove_reference\u003c/code\u003e和\u003ccode\u003estd::remove_cv\u003c/code\u003e进行了类型擦除，对\u003ccode\u003econst\u003c/code\u003e、\u003ccode\u003evolatile\u003c/code\u003e和引用进行去壳，移除我们不需要的特性.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e中定义了\u003ccode\u003eExtractor\u003c/code\u003e提取器结构，提取器内部的\u003ccode\u003eCall\u003c/code\u003e函数是一个指针，用来调用可调用对象。\u003c/p\u003e\n\u003cp\u003e接下来解释一下参数和返回值的数据结构。\u003c/p\u003e\n\u003cp\u003e分别是\u003ccode\u003eTVMArgs\u003c/code\u003e和\u003ccode\u003eTVMRetValue\u003c/code\u003e,都使用了联合体\u003ccode\u003eTVMValue\u003c/code\u003e对数据进行打包并进行了运算符重载和用于数据传递的基本方法。\u003c/p\u003e\n\u003cp\u003e以上所有的实现基本都在\u003ccode\u003einclude/tvm/runtime/packed_func.h\u003c/code\u003e、\u003ccode\u003einclude/tvm/runtime/registry.h\u003c/code\u003e和\u003ccode\u003esrc/runtime/registry.cc\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePython\u003c/code\u003e封装了\u003ccode\u003ectypes\u003c/code\u003e库，能够通过\u003ccode\u003ename\u003c/code\u003e查找全局注册的C++函数并获得函数句柄，调用后得到传回的返回值。\n其中对数据类型的包装也是TVM实现任意语言互相调用的关键。\u003c/p\u003e","title":""}]