[{"content":"首先给出TVM中注册自定义函数和调用自定义函数的方法\n// 注册函数 TVM_REGISTER_GLOBAL(\u0026#34;add\u0026#34;).set_body([](TVMArgs args, TVMRetValue* ret) { int a = args[0]; int b = args[1]; *ret = a + b; }); // 调用函数 PackedFunc add = runtime::Registry::Get(\u0026#34;add\u0026#34;); int result = add(3, 5); // 返回 8 TVM实现注册Lambda函数的set_body函数是一个指向PackedFunc类型的指针.\nTVM_REGISTER_GLOBAL的实现如下：\n#define REGISTER_GLOBAL(name, func) \\ tvm::runtime::FRegistry::Register(name, tvm::runtime::PackedFunc(func)) 使用全局哈希表FRegistry注册函数。通过宏REGISTER_GLOBAL(\u0026quot;func_name\u0026quot;, MyFunction)将函数与名称绑定，后续通过GetPackedFunc(\u0026quot;func_name\u0026quot;)查找.\n使用REGISTER_GLOBAL宏将函数与名称绑定。这个宏会调用FRegistry::Register方法，将函数存储到全局哈希表中。\nPackedFunc类型继承自ObjectRef基类，实现了运算符重载，又用make_object函数创建一个PackedFuncSubObj类型对象，这个对象可以储存可调用对象.\nPackedFuncSubObj继承自PackedFuncObj, 这是Object的子类，Object实现了引用计数和类型检查，PackedFunObj对函数指针、参数和返回值指针进行了打包。\nPackedFuncSubObj类型用std::remove_reference和std::remove_cv进行了类型擦除，对const、volatile和引用进行去壳，移除我们不需要的特性.\nPackedFuncSubObj中定义了Extractor提取器结构，提取器内部的Call函数是一个指针，用来调用可调用对象。\n接下来解释一下参数和返回值的数据结构。\n分别是TVMArgs和TVMRetValue,都使用了联合体TVMValue对数据进行打包并进行了运算符重载和用于数据传递的基本方法。\n以上所有的实现基本都在include/tvm/runtime/packed_func.h、include/tvm/runtime/registry.h和src/runtime/registry.cc\nPython封装了ctypes库，能够通过name查找全局注册的C++函数并获得函数句柄，调用后得到传回的返回值。 其中对数据类型的包装也是TVM实现任意语言互相调用的关键.\n","permalink":"https://KDZZZZZZ.github.io/posts/tvm%E4%BB%A3%E7%A0%81%E5%BA%93%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/","summary":"\u003cp\u003e首先给出TVM中注册自定义函数和调用自定义函数的方法\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 注册函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eTVM_REGISTER_GLOBAL(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;add\u0026#34;\u003c/span\u003e).set_body([](TVMArgs args, TVMRetValue\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ret) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e args[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e b \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e args[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eret \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 调用函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003ePackedFunc add \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e runtime\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eRegistry\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eGet(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;add\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e add(\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// 返回 8\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTVM实现注册Lambda函数的\u003ccode\u003eset_body\u003c/code\u003e函数是一个指向\u003ccode\u003ePackedFunc\u003c/code\u003e类型的指针.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTVM_REGISTER_GLOBAL\u003c/code\u003e的实现如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define REGISTER_GLOBAL(name, func) \\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e  tvm::runtime::FRegistry::Register(name, tvm::runtime::PackedFunc(func))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用全局哈希表\u003ccode\u003eFRegistry\u003c/code\u003e注册函数。通过宏\u003ccode\u003eREGISTER_GLOBAL(\u0026quot;func_name\u0026quot;, MyFunction)\u003c/code\u003e将函数与名称绑定，后续通过\u003ccode\u003eGetPackedFunc(\u0026quot;func_name\u0026quot;)\u003c/code\u003e查找.\u003c/p\u003e\n\u003cp\u003e使用\u003ccode\u003eREGISTER_GLOBAL\u003c/code\u003e宏将函数与名称绑定。这个宏会调用\u003ccode\u003eFRegistry::Register\u003c/code\u003e方法，将函数存储到全局哈希表中。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFunc\u003c/code\u003e类型继承自\u003ccode\u003eObjectRef\u003c/code\u003e基类，实现了运算符重载，又用\u003ccode\u003emake_object\u003c/code\u003e函数创建一个\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e类型对象，这个对象可以储存可调用对象.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e继承自\u003ccode\u003ePackedFuncObj\u003c/code\u003e, 这是\u003ccode\u003eObject\u003c/code\u003e的子类，\u003ccode\u003eObject\u003c/code\u003e实现了引用计数和类型检查，\u003ccode\u003ePackedFunObj\u003c/code\u003e对函数指针、参数和返回值指针进行了打包。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e类型用\u003ccode\u003estd::remove_reference\u003c/code\u003e和\u003ccode\u003estd::remove_cv\u003c/code\u003e进行了类型擦除，对\u003ccode\u003econst\u003c/code\u003e、\u003ccode\u003evolatile\u003c/code\u003e和引用进行去壳，移除我们不需要的特性.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e中定义了\u003ccode\u003eExtractor\u003c/code\u003e提取器结构，提取器内部的\u003ccode\u003eCall\u003c/code\u003e函数是一个指针，用来调用可调用对象。\u003c/p\u003e\n\u003cp\u003e接下来解释一下参数和返回值的数据结构。\u003c/p\u003e\n\u003cp\u003e分别是\u003ccode\u003eTVMArgs\u003c/code\u003e和\u003ccode\u003eTVMRetValue\u003c/code\u003e,都使用了联合体\u003ccode\u003eTVMValue\u003c/code\u003e对数据进行打包并进行了运算符重载和用于数据传递的基本方法。\u003c/p\u003e\n\u003cp\u003e以上所有的实现基本都在\u003ccode\u003einclude/tvm/runtime/packed_func.h\u003c/code\u003e、\u003ccode\u003einclude/tvm/runtime/registry.h\u003c/code\u003e和\u003ccode\u003esrc/runtime/registry.cc\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePython\u003c/code\u003e封装了\u003ccode\u003ectypes\u003c/code\u003e库，能够通过\u003ccode\u003ename\u003c/code\u003e查找全局注册的C++函数并获得函数句柄，调用后得到传回的返回值。\n其中对数据类型的包装也是TVM实现任意语言互相调用的关键.\u003c/p\u003e","title":"TVM Function objects and registration implementation"},{"content":"relay层主要由数据结构类(如Constant)和节点类(如ConstantNode)组成。 下面梳理一下他们的继承链。\nObjectRef → BaseExpr → RelayExpr → Constant\nObject → BaseExprNode → RelayExprNode → ConstantNode\n源代码库中使用了using ExprNode = tvm::RelayExprNode;\n这里先赘述一下上面每个类的的功能：\n(1) Object (include/tvm/runtime/object.h) 功能： TVM 所有对象的基类，提供 引用计数 和 类型系统 支持 实现 RefCount 机制（通过 use_count 成员） 提供 type_index 用于运行时类型识别（RTTI） 关键方法： virtual uint32_t type_index() const; // 类型标识 void IncRef(); // 增加引用计数 void DecRef(); // 减少引用计数 (2) ObjectRef (include/tvm/runtime/object.h) 功能： 所有 对象引用 的基类模板（如 Constant 本质是 ObjectRef\u0026lt;ConstantNode\u0026gt;） 通过智能指针 (ObjectPtr) 管理 Object 子类的生命周期 提供 类型安全转换接口（如 as\u0026lt;T\u0026gt;()） 关键行为： template\u0026lt;typename T\u0026gt; const T* as() const; // 安全类型转换 operator bool() const; // 检查是否非空 (3) BaseExprNode (include/tvm/ir/expr.h) 继承关系：Object → BaseExprNode 功能： 所有 表达式节点 的抽象基类 定义表达式通用接口： 数据类型 (dtype) 源码位置 (span) 虚函数 SEqualReduce（用于结构相等性比较） 关键成员： runtime::DataType dtype; // 数据类型（如 float32） Span span; // 源码位置信息（用于调试） (4) BaseExpr (include/tvm/ir/expr.h) 继承关系：ObjectRef → BaseExpr 功能： 所有 表达式引用 的基类（如 Constant、Var 等） 提供对 BaseExprNode 的通用访问接口 重载运算符（如 operator==）实现表达式比较 (5) RelayExprNode (include/tvm/ir/expr.h) 继承关系：BaseExprNode → RelayExprNode 功能： Relay 表达式体系的节点基类，定义所有高层计算图节点的通用行为 存储 Relay 特有的元数据： 类型信息 (checked_type_): 类型推断后的结果（如 TensorType(shape=[1,3], dtype=float32)） 源码位置 (span): 用于调试和错误定位 实现 结构等价性检查 (SEqualReduce) 和 哈希生成 (SHashReduce) 的虚函数 支持 递归遍历子节点 的接口（用于优化 Pass 或分析） 关键成员： mutable Type checked_type_; // 类型推断结果（可缓存） Span span; // 源码位置信息 典型子类： ConstantNode（常量） VarNode（变量） CallNode（函数调用） FunctionNode（函数定义） (6) RelayExpr (include/tvm/ir/expr.h) 继承关系：BaseExpr → RelayExpr 功能： 通过TVM_DEFINE_OBJECT_REF_METHODS宏定义了对象引用管理、类型转换和节点访问的功能 (7) ConstantNode (include/tvm/relay/expr.h) 继承关系：RelayExprNode → ConstantNode 功能： 存储常量数据的节点（具体实现） 持有 runtime::NDArray 表示常量值 实现 SEqualReduce 比较常量值是否相等 实现 SHashReduce 生成哈希值 关键成员： runtime::NDArray data; // 常量数据（可以是标量或张量） (8) Constant (include/tvm/relay/expr.h) 继承关系：RelayExpr → Constant 功能： 用户直接使用的常量包装类 构造函数封装 ConstantNode 的创建 提供对 data 的安全访问方法 示例用法： NDArray arr = ...; Constant c = Constant(arr); // 创建常量 Expr expr = c; // 可隐式转换为基类 有了对基类的功能认识，我们只需要继续了解类似Constant和ConstantNode类的其他主要类实现。\n2. 数据节点：常量与变量 (1) ConstantNode 继承关系: RelayExprNode → ConstantNode 功能: 存储计算图中的常量数据（如模型权重） 成员变量: runtime::NDArray data; // 数据载体（支持标量、向量、张量） 方法: SEqualReduce: 比较两个 NDArray 是否逐元素相等 SHashReduce: 基于 NDArray 数据生成哈希 包装类: Constant class Constant : public RelayExpr { public: explicit Constant(runtime::NDArray data); const ConstantNode* operator-\u0026gt;() const; }; (2) VarNode 继承关系: RelayExprNode → VarNode 功能: 表示计算图中的变量（输入/中间变量） 成员变量: Id vid; // 变量唯一标识符（如 %x） Type type_annotation; // 显式类型注解（可选） 包装类: Var class Var : public RelayExpr { public: Var(Id vid, Type type_annotation = Type(nullptr)); static Var Create(Id vid, Type type_annotation); // 工厂方法 }; 3. 计算节点：算子与流程控制 (1) CallNode 继承关系: RelayExprNode → CallNode 功能: 表示函数或算子的调用 成员变量: RelayExpr op; // 被调用的函数/算子（可以是Var或Function） Array\u0026lt;RelayExpr\u0026gt; args; // 调用参数列表 Attrs attrs; // 算子属性（如卷积的stride、padding） 包装类: Call class Call : public RelayExpr { public: Call(RelayExpr op, Array\u0026lt;RelayExpr\u0026gt; args, Attrs attrs = Attrs()); }; (2) FunctionNode 继承关系: RelayExprNode → FunctionNode 功能: 定义 Relay 函数（类似 Lambda 表达式） 成员变量: Array\u0026lt;Var\u0026gt; params; // 函数参数列表 RelayExpr body; // 函数体表达式 Type ret_type; // 显式声明的返回类型 包装类: Function class Function : public RelayExpr { public: Function(Array\u0026lt;Var\u0026gt; params, RelayExpr body, Type ret_type); }; (3) IfNode 继承关系: RelayExprNode → IfNode 功能: 条件分支控制流 成员变量: RelayExpr cond; // 条件表达式（需为布尔标量） RelayExpr true_branch; // 条件为真时执行的表达式 RelayExpr false_branch; // 条件为假时执行的表达式 包装类: If class If : public RelayExpr { public: If(RelayExpr cond, RelayExpr true_branch, RelayExpr false_branch); }; 4. 复合结构节点 (1) TupleNode 继承关系: RelayExprNode → TupleNode 功能: 存储多个表达式的元组 成员变量: Array\u0026lt;RelayExpr\u0026gt; fields; // 元组中的元素列表 包装类: Tuple class Tuple : public RelayExpr { public: explicit Tuple(Array\u0026lt;RelayExpr\u0026gt; fields); }; (2) TupleGetItemNode 继承关系: RelayExprNode → TupleGetItemNode 功能: 从元组中按索引取值 成员变量: RelayExpr tuple; // 目标元组 int index; // 索引值（从0开始） 包装类: TupleGetItem class TupleGetItem : public RelayExpr { public: TupleGetItem(RelayExpr tuple, int index); }; (3) LetNode 继承关系: RelayExprNode → LetNode 功能: 绑定局部变量（类似 let-in 表达式） 成员变量: Var var; // 绑定的变量 RelayExpr value; // 变量的值 RelayExpr body; // 变量作用域内的表达式 包装类: Let class Let : public RelayExpr { public: Let(Var var, RelayExpr value, RelayExpr body); }; 节点连接方式 class CallNode : public RelayExprNode { public: RelayExpr op; // 被调用的算子（ObjectRef\u0026lt;RelayExprNode\u0026gt;） Array\u0026lt;RelayExpr\u0026gt; args; // 参数列表（ObjectRef 的容器） }; 这里的Array用来储存上面的一切包装类(如Constant，用来引用节点)。 Array的结构是vector\u0026lt;ObjectRef\u0026gt;.\nAST示例 // 构建表达式：add(mul(x, 2), y) relay::Var x = relay::Var(\u0026#34;x\u0026#34;, TensorType({1}, DataType::Float(32))); relay::Var y = relay::Var(\u0026#34;y\u0026#34;, TensorType({1}, DataType::Float(32))); relay::Constant two = relay::Constant(runtime::NDArray::Scalar(2.0f)); // 节点连接关系： // add_op -\u0026gt; CallNode // ├── op : FunctionRef (指向加法算子) // │ ├── op : FunctionRef (指向乘法算子) // │ ├── args[0]: VarNode (x) // │ └── args[1]: ConstantNode (2) // └── args[1]: VarNode (y) relay::Call mul = relay::Call(mul_op, {x, two}); relay::Call add = relay::Call(add_op, {mul, y}); Pass Pass的结构和继承关系也分为节点类和引用类两支。\n使用PassRegistry全局注册表来管理 Pass。下面依次叙述一下各个类的功能。\nPass继承自ObjectRef是所有引用类的基类\nPassNode继承自Object是所有节点类的基类\nPassContext储存了上下文信息，如优化级别、依赖的Pass、配置等。\nPassInfo储存了Pass的名称、描述、依赖关系等信息。\nSequential引用类\nSequentialNode储存PassInfo和Array\u0026lt;Pass\u0026gt;，实现了遍历、执行、解析依赖的功能。 在include/tvm/ir/transform.h中定义。\nCreateFunctionPass定义了函数级优化Pass CreateModulePass定义了模块级优化Pass\n","permalink":"https://KDZZZZZZ.github.io/posts/tvm%E4%BB%A3%E7%A0%81%E5%BA%93%E8%A7%A3%E6%9E%90relay%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96pass/","summary":"\u003cp\u003erelay层主要由数据结构类(如Constant)和节点类(如ConstantNode)组成。\n下面梳理一下他们的继承链。\u003c/p\u003e\n\u003cp\u003eObjectRef → BaseExpr → RelayExpr → Constant\u003c/p\u003e\n\u003cp\u003eObject → BaseExprNode → RelayExprNode → ConstantNode\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e源代码库中使用了\u003ccode\u003eusing ExprNode = tvm::RelayExprNode;\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这里先赘述一下上面每个类的的功能：\u003c/p\u003e\n\u003ch4 id=\"1-object-includetvmruntimeobjecth\"\u003e\u003cstrong\u003e(1) \u003ccode\u003eObject\u003c/code\u003e (include/tvm/runtime/object.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003eTVM \u003cstrong\u003e所有对象的基类\u003c/strong\u003e，提供 \u003cstrong\u003e引用计数\u003c/strong\u003e 和 \u003cstrong\u003e类型系统\u003c/strong\u003e 支持\u003c/li\u003e\n\u003cli\u003e实现 \u003ccode\u003eRefCount\u003c/code\u003e 机制（通过 \u003ccode\u003euse_count\u003c/code\u003e 成员）\u003c/li\u003e\n\u003cli\u003e提供 \u003ccode\u003etype_index\u003c/code\u003e 用于运行时类型识别（RTTI）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键方法\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evirtual\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype_index\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// 类型标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eIncRef\u003c/span\u003e();  \u003cspan style=\"color:#75715e\"\u003e// 增加引用计数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDecRef\u003c/span\u003e();  \u003cspan style=\"color:#75715e\"\u003e// 减少引用计数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-objectref-includetvmruntimeobjecth\"\u003e\u003cstrong\u003e(2) \u003ccode\u003eObjectRef\u003c/code\u003e (include/tvm/runtime/object.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e所有 \u003cstrong\u003e对象引用\u003c/strong\u003e 的基类模板（如 \u003ccode\u003eConstant\u003c/code\u003e 本质是 \u003ccode\u003eObjectRef\u0026lt;ConstantNode\u0026gt;\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e通过智能指针 (\u003ccode\u003eObjectPtr\u003c/code\u003e) \u003cstrong\u003e管理 Object 子类的生命周期\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e提供 \u003cstrong\u003e类型安全转换接口\u003c/strong\u003e（如 \u003ccode\u003eas\u0026lt;T\u0026gt;()\u003c/code\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键行为\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e as() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// 安全类型转换\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebool\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// 检查是否非空\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"3-baseexprnode-includetvmirexprh\"\u003e\u003cstrong\u003e(3) \u003ccode\u003eBaseExprNode\u003c/code\u003e (include/tvm/ir/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eObject\u003c/code\u003e → \u003ccode\u003eBaseExprNode\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e所有 \u003cstrong\u003e表达式节点\u003c/strong\u003e 的抽象基类\u003c/li\u003e\n\u003cli\u003e定义表达式通用接口：\n\u003cul\u003e\n\u003cli\u003e数据类型 (\u003ccode\u003edtype\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e源码位置 (\u003ccode\u003espan\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e虚函数 \u003ccode\u003eSEqualReduce\u003c/code\u003e（用于结构相等性比较）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键成员\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eruntime\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eDataType dtype; \u003cspan style=\"color:#75715e\"\u003e// 数据类型（如 float32）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eSpan span;               \u003cspan style=\"color:#75715e\"\u003e// 源码位置信息（用于调试）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"4-baseexpr-includetvmirexprh\"\u003e\u003cstrong\u003e(4) \u003ccode\u003eBaseExpr\u003c/code\u003e (include/tvm/ir/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eObjectRef\u003c/code\u003e → \u003ccode\u003eBaseExpr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e所有 \u003cstrong\u003e表达式引用\u003c/strong\u003e 的基类（如 \u003ccode\u003eConstant\u003c/code\u003e、\u003ccode\u003eVar\u003c/code\u003e 等）\u003c/li\u003e\n\u003cli\u003e提供对 \u003ccode\u003eBaseExprNode\u003c/code\u003e 的通用访问接口\u003c/li\u003e\n\u003cli\u003e重载运算符（如 \u003ccode\u003eoperator==\u003c/code\u003e）实现表达式比较\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"5-relayexprnode-includetvmirexprh\"\u003e\u003cstrong\u003e(5) \u003ccode\u003eRelayExprNode\u003c/code\u003e (include/tvm/ir/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eBaseExprNode\u003c/code\u003e → \u003ccode\u003eRelayExprNode\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRelay 表达式体系的节点基类\u003c/strong\u003e，定义所有高层计算图节点的通用行为\u003c/li\u003e\n\u003cli\u003e存储 Relay 特有的元数据：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e类型信息\u003c/strong\u003e (\u003ccode\u003echecked_type_\u003c/code\u003e): 类型推断后的结果（如 \u003ccode\u003eTensorType(shape=[1,3], dtype=float32)\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e源码位置\u003c/strong\u003e (\u003ccode\u003espan\u003c/code\u003e): 用于调试和错误定位\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e实现 \u003cstrong\u003e结构等价性检查\u003c/strong\u003e (\u003ccode\u003eSEqualReduce\u003c/code\u003e) 和 \u003cstrong\u003e哈希生成\u003c/strong\u003e (\u003ccode\u003eSHashReduce\u003c/code\u003e) 的虚函数\u003c/li\u003e\n\u003cli\u003e支持 \u003cstrong\u003e递归遍历子节点\u003c/strong\u003e 的接口（用于优化 Pass 或分析）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键成员\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003emutable\u003c/span\u003e Type checked_type_;  \u003cspan style=\"color:#75715e\"\u003e// 类型推断结果（可缓存）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eSpan span;                   \u003cspan style=\"color:#75715e\"\u003e// 源码位置信息\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e典型子类\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eConstantNode\u003c/code\u003e（常量）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eVarNode\u003c/code\u003e（变量）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCallNode\u003c/code\u003e（函数调用）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFunctionNode\u003c/code\u003e（函数定义）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"6-relayexpr-includetvmirexprh\"\u003e\u003cstrong\u003e(6) \u003ccode\u003eRelayExpr\u003c/code\u003e (include/tvm/ir/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eBaseExpr\u003c/code\u003e → \u003ccode\u003eRelayExpr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e通过\u003ccode\u003eTVM_DEFINE_OBJECT_REF_METHODS\u003c/code\u003e宏定义了对象引用管理、类型转换和节点访问的功能\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"7-constantnode-includetvmrelayexprh\"\u003e\u003cstrong\u003e(7) \u003ccode\u003eConstantNode\u003c/code\u003e (include/tvm/relay/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eRelayExprNode\u003c/code\u003e → \u003ccode\u003eConstantNode\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储常量数据的节点\u003c/strong\u003e（具体实现）\u003c/li\u003e\n\u003cli\u003e持有 \u003ccode\u003eruntime::NDArray\u003c/code\u003e 表示常量值\u003c/li\u003e\n\u003cli\u003e实现 \u003ccode\u003eSEqualReduce\u003c/code\u003e 比较常量值是否相等\u003c/li\u003e\n\u003cli\u003e实现 \u003ccode\u003eSHashReduce\u003c/code\u003e 生成哈希值\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键成员\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eruntime\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eNDArray data; \u003cspan style=\"color:#75715e\"\u003e// 常量数据（可以是标量或张量）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"8-constant-includetvmrelayexprh\"\u003e\u003cstrong\u003e(8) \u003ccode\u003eConstant\u003c/code\u003e (include/tvm/relay/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eRelayExpr\u003c/code\u003e → \u003ccode\u003eConstant\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e用户直接使用的常量包装类\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e构造函数封装 \u003ccode\u003eConstantNode\u003c/code\u003e 的创建\u003c/li\u003e\n\u003cli\u003e提供对 \u003ccode\u003edata\u003c/code\u003e 的安全访问方法\u003c/li\u003e\n\u003cli\u003e示例用法：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eNDArray arr \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e ...;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eConstant c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Constant(arr);  \u003cspan style=\"color:#75715e\"\u003e// 创建常量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eExpr expr \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e c;               \u003cspan style=\"color:#75715e\"\u003e// 可隐式转换为基类\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e有了对基类的功能认识，我们只需要继续了解类似\u003ccode\u003eConstant\u003c/code\u003e和\u003ccode\u003eConstantNode\u003c/code\u003e类的其他主要类实现。\u003c/p\u003e","title":"TVM代码库解析：Relay层结构与优化Pass"},{"content":"Welcome! Hello everyone! This is my new blog built with Hugo. I\u0026rsquo;m excited to share my thoughts and experiences here.\nWhat to Expect In this blog, I plan to write about:\nTechnology and Programming Learning experiences Personal growth Interesting projects Why I Started Blogging I believe writing is a great way to:\nOrganize thoughts Share knowledge Document learning journey Connect with like-minded people Stay tuned for more posts!\n","permalink":"https://KDZZZZZZ.github.io/posts/welcome-to-my-blog/","summary":"\u003ch2 id=\"welcome\"\u003eWelcome!\u003c/h2\u003e\n\u003cp\u003eHello everyone! This is my new blog built with Hugo. I\u0026rsquo;m excited to share my thoughts and experiences here.\u003c/p\u003e\n\u003ch3 id=\"what-to-expect\"\u003eWhat to Expect\u003c/h3\u003e\n\u003cp\u003eIn this blog, I plan to write about:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTechnology and Programming\u003c/li\u003e\n\u003cli\u003eLearning experiences\u003c/li\u003e\n\u003cli\u003ePersonal growth\u003c/li\u003e\n\u003cli\u003eInteresting projects\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"why-i-started-blogging\"\u003eWhy I Started Blogging\u003c/h3\u003e\n\u003cp\u003eI believe writing is a great way to:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOrganize thoughts\u003c/li\u003e\n\u003cli\u003eShare knowledge\u003c/li\u003e\n\u003cli\u003eDocument learning journey\u003c/li\u003e\n\u003cli\u003eConnect with like-minded people\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned for more posts!\u003c/p\u003e","title":"Welcome to My Blog"},{"content":"欢迎来到我的博客！ 这是我用 Hugo 搭建的新博客的第一篇文章。我很高兴能在这里开始分享我的想法和经历。\n期待 我会在这里写一些我感兴趣的话题。敬请期待更多内容！\n","permalink":"https://KDZZZZZZ.github.io/posts/my-first-post/","summary":"\u003ch1 id=\"欢迎来到我的博客\"\u003e欢迎来到我的博客！\u003c/h1\u003e\n\u003cp\u003e这是我用 Hugo 搭建的新博客的第一篇文章。我很高兴能在这里开始分享我的想法和经历。\u003c/p\u003e\n\u003ch2 id=\"期待\"\u003e期待\u003c/h2\u003e\n\u003cp\u003e我会在这里写一些我感兴趣的话题。敬请期待更多内容！\u003c/p\u003e","title":"我的第一篇博客"},{"content":"Oops，本科就读于杭州电子科技大学CS系28级，渴望灵感之风的吹拂也希望夯实工程能力。\n虚度的时间 探索了CS的必修四件套，go后端入门，NLP算法基础，以及一些电子元件的理论知识。还有一些比赛、外包项目。\n痛定思痛 接下来我将继续MLSys方向，同时分享一些ML和DL算法和论文复现。或许还有一些微调RAG提示词工程的笔记。靡不有初，鲜克有终。\n关于博客 理论会尽力严谨，如果有教程会尽力细致，如果有随笔会尽量随便。\nGitHub: KDZZZZZZ Email: QQ邮箱 bilibili: 在B站考研 会赢的，对吧\n","permalink":"https://KDZZZZZZ.github.io/about/","summary":"\u003cp\u003eOops，本科就读于杭州电子科技大学CS系28级，渴望灵感之风的吹拂也希望夯实工程能力。\u003c/p\u003e\n\u003ch2 id=\"虚度的时间\"\u003e虚度的时间\u003c/h2\u003e\n\u003cp\u003e探索了CS的必修四件套，go后端入门，NLP算法基础，以及一些电子元件的理论知识。还有一些比赛、外包项目。\u003c/p\u003e\n\u003ch2 id=\"痛定思痛\"\u003e痛定思痛\u003c/h2\u003e\n\u003cp\u003e接下来我将继续MLSys方向，同时分享一些ML和DL算法和论文复现。或许还有一些微调RAG提示词工程的笔记。靡不有初，鲜克有终。\u003c/p\u003e\n\u003ch2 id=\"关于博客\"\u003e关于博客\u003c/h2\u003e\n\u003cp\u003e理论会尽力严谨，如果有教程会尽力细致，如果有随笔会尽量随便。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub: \u003ca href=\"https://github.com/KDZZZZZZ\"\u003eKDZZZZZZ\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eEmail: \u003ca href=\"mailto:2112335382@qq.com\"\u003eQQ邮箱\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ebilibili: \u003ca href=\"https://space.bilibili.com/1938413314?spm_id_from=333.1007.0.0\"\u003e在B站考研\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e会赢的，对吧\u003c/p\u003e","title":"About Me"},{"content":"Hello, World! This is my first blog post. Here, I\u0026rsquo;ll share some interesting tech insights and life experiences.\nWhy Start a Blog? Blogging helps me:\nDocument my learning journey Share technical insights Connect with like-minded people Future Plans I plan to write about:\nProgramming techniques Learning experiences Life reflections Stay tuned!\n","permalink":"https://KDZZZZZZ.github.io/posts/hello-world/","summary":"\u003ch2 id=\"hello-world\"\u003eHello, World!\u003c/h2\u003e\n\u003cp\u003eThis is my first blog post. Here, I\u0026rsquo;ll share some interesting tech insights and life experiences.\u003c/p\u003e\n\u003ch3 id=\"why-start-a-blog\"\u003eWhy Start a Blog?\u003c/h3\u003e\n\u003cp\u003eBlogging helps me:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDocument my learning journey\u003c/li\u003e\n\u003cli\u003eShare technical insights\u003c/li\u003e\n\u003cli\u003eConnect with like-minded people\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"future-plans\"\u003eFuture Plans\u003c/h3\u003e\n\u003cp\u003eI plan to write about:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProgramming techniques\u003c/li\u003e\n\u003cli\u003eLearning experiences\u003c/li\u003e\n\u003cli\u003eLife reflections\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned!\u003c/p\u003e","title":"Hello World"}]