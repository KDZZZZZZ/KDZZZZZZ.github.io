[{"content":"首先给出TVM中注册自定义函数和调用自定义函数的方法\n// 注册函数 TVM_REGISTER_GLOBAL(\u0026#34;add\u0026#34;).set_body([](TVMArgs args, TVMRetValue* ret) { int a = args[0]; int b = args[1]; *ret = a + b; }); // 调用函数 PackedFunc add = runtime::Registry::Get(\u0026#34;add\u0026#34;); int result = add(3, 5); // 返回 8 TVM实现注册Lambda函数的set_body函数是一个指向PackedFunc类型的指针.\nTVM_REGISTER_GLOBAL的实现如下：\n#define REGISTER_GLOBAL(name, func) \\ tvm::runtime::FRegistry::Register(name, tvm::runtime::PackedFunc(func)) 使用全局哈希表FRegistry注册函数。通过宏REGISTER_GLOBAL(\u0026quot;func_name\u0026quot;, MyFunction)将函数与名称绑定，后续通过GetPackedFunc(\u0026quot;func_name\u0026quot;)查找.\n使用REGISTER_GLOBAL宏将函数与名称绑定。这个宏会调用FRegistry::Register方法，将函数存储到全局哈希表中。\nPackedFunc类型继承自ObjectRef基类，实现了运算符重载，又用make_object函数创建一个PackedFuncSubObj类型对象，这个对象可以储存可调用对象.\nPackedFuncSubObj继承自PackedFuncObj, 这是Object的子类，Object实现了引用计数和类型检查，PackedFunObj对函数指针、参数和返回值指针进行了打包。\nPackedFuncSubObj类型用std::remove_reference和std::remove_cv进行了类型擦除，对const、volatile和引用进行去壳，移除我们不需要的特性.\nPackedFuncSubObj中定义了Extractor提取器结构，提取器内部的Call函数是一个指针，用来调用可调用对象。\n接下来解释一下参数和返回值的数据结构。\n分别是TVMArgs和TVMRetValue,都使用了联合体TVMValue对数据进行打包并进行了运算符重载和用于数据传递的基本方法。\n以上所有的实现基本都在include/tvm/runtime/packed_func.h、include/tvm/runtime/registry.h和src/runtime/registry.cc\nPython封装了ctypes库，能够通过name查找全局注册的C++函数并获得函数句柄，调用后得到传回的返回值。 其中对数据类型的包装也是TVM实现任意语言互相调用的关键.\n","permalink":"https://KDZZZZZZ.github.io/posts/tvm%E4%BB%A3%E7%A0%81%E5%BA%93%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/","summary":"\u003cp\u003e首先给出TVM中注册自定义函数和调用自定义函数的方法\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 注册函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eTVM_REGISTER_GLOBAL(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;add\u0026#34;\u003c/span\u003e).set_body([](TVMArgs args, TVMRetValue\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ret) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e args[\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e b \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e args[\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eret \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e b;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 调用函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003ePackedFunc add \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e runtime\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eRegistry\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eGet(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;add\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e add(\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e);  \u003cspan style=\"color:#75715e\"\u003e// 返回 8\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTVM实现注册Lambda函数的\u003ccode\u003eset_body\u003c/code\u003e函数是一个指向\u003ccode\u003ePackedFunc\u003c/code\u003e类型的指针.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTVM_REGISTER_GLOBAL\u003c/code\u003e的实现如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define REGISTER_GLOBAL(name, func) \\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e  tvm::runtime::FRegistry::Register(name, tvm::runtime::PackedFunc(func))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用全局哈希表\u003ccode\u003eFRegistry\u003c/code\u003e注册函数。通过宏\u003ccode\u003eREGISTER_GLOBAL(\u0026quot;func_name\u0026quot;, MyFunction)\u003c/code\u003e将函数与名称绑定，后续通过\u003ccode\u003eGetPackedFunc(\u0026quot;func_name\u0026quot;)\u003c/code\u003e查找.\u003c/p\u003e\n\u003cp\u003e使用\u003ccode\u003eREGISTER_GLOBAL\u003c/code\u003e宏将函数与名称绑定。这个宏会调用\u003ccode\u003eFRegistry::Register\u003c/code\u003e方法，将函数存储到全局哈希表中。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFunc\u003c/code\u003e类型继承自\u003ccode\u003eObjectRef\u003c/code\u003e基类，实现了运算符重载，又用\u003ccode\u003emake_object\u003c/code\u003e函数创建一个\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e类型对象，这个对象可以储存可调用对象.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e继承自\u003ccode\u003ePackedFuncObj\u003c/code\u003e, 这是\u003ccode\u003eObject\u003c/code\u003e的子类，\u003ccode\u003eObject\u003c/code\u003e实现了引用计数和类型检查，\u003ccode\u003ePackedFunObj\u003c/code\u003e对函数指针、参数和返回值指针进行了打包。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e类型用\u003ccode\u003estd::remove_reference\u003c/code\u003e和\u003ccode\u003estd::remove_cv\u003c/code\u003e进行了类型擦除，对\u003ccode\u003econst\u003c/code\u003e、\u003ccode\u003evolatile\u003c/code\u003e和引用进行去壳，移除我们不需要的特性.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePackedFuncSubObj\u003c/code\u003e中定义了\u003ccode\u003eExtractor\u003c/code\u003e提取器结构，提取器内部的\u003ccode\u003eCall\u003c/code\u003e函数是一个指针，用来调用可调用对象。\u003c/p\u003e\n\u003cp\u003e接下来解释一下参数和返回值的数据结构。\u003c/p\u003e\n\u003cp\u003e分别是\u003ccode\u003eTVMArgs\u003c/code\u003e和\u003ccode\u003eTVMRetValue\u003c/code\u003e,都使用了联合体\u003ccode\u003eTVMValue\u003c/code\u003e对数据进行打包并进行了运算符重载和用于数据传递的基本方法。\u003c/p\u003e\n\u003cp\u003e以上所有的实现基本都在\u003ccode\u003einclude/tvm/runtime/packed_func.h\u003c/code\u003e、\u003ccode\u003einclude/tvm/runtime/registry.h\u003c/code\u003e和\u003ccode\u003esrc/runtime/registry.cc\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePython\u003c/code\u003e封装了\u003ccode\u003ectypes\u003c/code\u003e库，能够通过\u003ccode\u003ename\u003c/code\u003e查找全局注册的C++函数并获得函数句柄，调用后得到传回的返回值。\n其中对数据类型的包装也是TVM实现任意语言互相调用的关键.\u003c/p\u003e","title":"TVM Function objects and registration implementation"},{"content":"relay层主要由数据结构类(如Constant)和节点类(如ConstantNode)组成。 下面梳理一下他们的继承链。\nObjectRef → BaseExpr → RelayExpr → Constant\nObject → BaseExprNode → RelayExprNode → ConstantNode\n源代码库中使用了using ExprNode = tvm::RelayExprNode;\n这里先赘述一下上面每个类的的功能：\n(1) Object (include/tvm/runtime/object.h) 功能： TVM 所有对象的基类，提供 引用计数 和 类型系统 支持 实现 RefCount 机制（通过 use_count 成员） 提供 type_index 用于运行时类型识别（RTTI） 关键方法： virtual uint32_t type_index() const; // 类型标识 void IncRef(); // 增加引用计数 void DecRef(); // 减少引用计数 (2) ObjectRef (include/tvm/runtime/object.h) 功能： 所有 对象引用 的基类模板（如 Constant 本质是 ObjectRef\u0026lt;ConstantNode\u0026gt;） 通过智能指针 (ObjectPtr) 管理 Object 子类的生命周期 提供 类型安全转换接口（如 as\u0026lt;T\u0026gt;()） 关键行为： template\u0026lt;typename T\u0026gt; const T* as() const; // 安全类型转换 operator bool() const; // 检查是否非空 (3) BaseExprNode (include/tvm/ir/expr.h) 继承关系：Object → BaseExprNode 功能： 所有 表达式节点 的抽象基类 定义表达式通用接口： 数据类型 (dtype) 源码位置 (span) 虚函数 SEqualReduce（用于结构相等性比较） 关键成员： runtime::DataType dtype; // 数据类型（如 float32） Span span; // 源码位置信息（用于调试） (4) BaseExpr (include/tvm/ir/expr.h) 继承关系：ObjectRef → BaseExpr 功能： 所有 表达式引用 的基类（如 Constant、Var 等） 提供对 BaseExprNode 的通用访问接口 重载运算符（如 operator==）实现表达式比较 (5) RelayExprNode (include/tvm/ir/expr.h) 继承关系：BaseExprNode → RelayExprNode 功能： Relay 表达式体系的节点基类，定义所有高层计算图节点的通用行为 存储 Relay 特有的元数据： 类型信息 (checked_type_): 类型推断后的结果（如 TensorType(shape=[1,3], dtype=float32)） 源码位置 (span): 用于调试和错误定位 实现 结构等价性检查 (SEqualReduce) 和 哈希生成 (SHashReduce) 的虚函数 支持 递归遍历子节点 的接口（用于优化 Pass 或分析） 关键成员： mutable Type checked_type_; // 类型推断结果（可缓存） Span span; // 源码位置信息 典型子类： ConstantNode（常量） VarNode（变量） CallNode（函数调用） FunctionNode（函数定义） (6) RelayExpr (include/tvm/ir/expr.h) 继承关系：BaseExpr → RelayExpr 功能： 通过TVM_DEFINE_OBJECT_REF_METHODS宏定义了对象引用管理、类型转换和节点访问的功能 (7) ConstantNode (include/tvm/relay/expr.h) 继承关系：RelayExprNode → ConstantNode 功能： 存储常量数据的节点（具体实现） 持有 runtime::NDArray 表示常量值 实现 SEqualReduce 比较常量值是否相等 实现 SHashReduce 生成哈希值 关键成员： runtime::NDArray data; // 常量数据（可以是标量或张量） (8) Constant (include/tvm/relay/expr.h) 继承关系：RelayExpr → Constant 功能： 用户直接使用的常量包装类 构造函数封装 ConstantNode 的创建 提供对 data 的安全访问方法 示例用法： NDArray arr = ...; Constant c = Constant(arr); // 创建常量 Expr expr = c; // 可隐式转换为基类 有了对基类的功能认识，我们只需要继续了解类似Constant和ConstantNode类的其他主要类实现。\n2. 数据节点：常量与变量 (1) ConstantNode 继承关系: RelayExprNode → ConstantNode 功能: 存储计算图中的常量数据（如模型权重） 成员变量: runtime::NDArray data; // 数据载体（支持标量、向量、张量） 方法: SEqualReduce: 比较两个 NDArray 是否逐元素相等 SHashReduce: 基于 NDArray 数据生成哈希 包装类: Constant class Constant : public RelayExpr { public: explicit Constant(runtime::NDArray data); const ConstantNode* operator-\u0026gt;() const; }; (2) VarNode 继承关系: RelayExprNode → VarNode 功能: 表示计算图中的变量（输入/中间变量） 成员变量: Id vid; // 变量唯一标识符（如 %x） Type type_annotation; // 显式类型注解（可选） 包装类: Var class Var : public RelayExpr { public: Var(Id vid, Type type_annotation = Type(nullptr)); static Var Create(Id vid, Type type_annotation); // 工厂方法 }; 3. 计算节点：算子与流程控制 (1) CallNode 继承关系: RelayExprNode → CallNode 功能: 表示函数或算子的调用 成员变量: RelayExpr op; // 被调用的函数/算子（可以是Var或Function） Array\u0026lt;RelayExpr\u0026gt; args; // 调用参数列表 Attrs attrs; // 算子属性（如卷积的stride、padding） 包装类: Call class Call : public RelayExpr { public: Call(RelayExpr op, Array\u0026lt;RelayExpr\u0026gt; args, Attrs attrs = Attrs()); }; (2) FunctionNode 继承关系: RelayExprNode → FunctionNode 功能: 定义 Relay 函数（类似 Lambda 表达式） 成员变量: Array\u0026lt;Var\u0026gt; params; // 函数参数列表 RelayExpr body; // 函数体表达式 Type ret_type; // 显式声明的返回类型 包装类: Function class Function : public RelayExpr { public: Function(Array\u0026lt;Var\u0026gt; params, RelayExpr body, Type ret_type); }; (3) IfNode 继承关系: RelayExprNode → IfNode 功能: 条件分支控制流 成员变量: RelayExpr cond; // 条件表达式（需为布尔标量） RelayExpr true_branch; // 条件为真时执行的表达式 RelayExpr false_branch; // 条件为假时执行的表达式 包装类: If class If : public RelayExpr { public: If(RelayExpr cond, RelayExpr true_branch, RelayExpr false_branch); }; 4. 复合结构节点 (1) TupleNode 继承关系: RelayExprNode → TupleNode 功能: 存储多个表达式的元组 成员变量: Array\u0026lt;RelayExpr\u0026gt; fields; // 元组中的元素列表 包装类: Tuple class Tuple : public RelayExpr { public: explicit Tuple(Array\u0026lt;RelayExpr\u0026gt; fields); }; (2) TupleGetItemNode 继承关系: RelayExprNode → TupleGetItemNode 功能: 从元组中按索引取值 成员变量: RelayExpr tuple; // 目标元组 int index; // 索引值（从0开始） 包装类: TupleGetItem class TupleGetItem : public RelayExpr { public: TupleGetItem(RelayExpr tuple, int index); }; (3) LetNode 继承关系: RelayExprNode → LetNode 功能: 绑定局部变量（类似 let-in 表达式） 成员变量: Var var; // 绑定的变量 RelayExpr value; // 变量的值 RelayExpr body; // 变量作用域内的表达式 包装类: Let class Let : public RelayExpr { public: Let(Var var, RelayExpr value, RelayExpr body); }; 节点连接方式 class CallNode : public RelayExprNode { public: RelayExpr op; // 被调用的算子（ObjectRef\u0026lt;RelayExprNode\u0026gt;） Array\u0026lt;RelayExpr\u0026gt; args; // 参数列表（ObjectRef 的容器） }; 这里的Array用来储存上面的一切包装类(如Constant，用来引用节点)。 Array的结构是vector\u0026lt;ObjectRef\u0026gt;.\nAST示例 // 构建表达式：add(mul(x, 2), y) relay::Var x = relay::Var(\u0026#34;x\u0026#34;, TensorType({1}, DataType::Float(32))); relay::Var y = relay::Var(\u0026#34;y\u0026#34;, TensorType({1}, DataType::Float(32))); relay::Constant two = relay::Constant(runtime::NDArray::Scalar(2.0f)); // 节点连接关系： // add_op -\u0026gt; CallNode // ├── op : FunctionRef (指向加法算子) // │ ├── op : FunctionRef (指向乘法算子) // │ ├── args[0]: VarNode (x) // │ └── args[1]: ConstantNode (2) // └── args[1]: VarNode (y) relay::Call mul = relay::Call(mul_op, {x, two}); relay::Call add = relay::Call(add_op, {mul, y}); Pass Pass的结构和继承关系也分为节点类和引用类两支。\n使用PassRegistry全局注册表来管理 Pass。下面依次叙述一下各个类的功能。\nPass继承自ObjectRef是所有引用类的基类\nPassNode继承自Object是所有节点类的基类\nPassContext储存了上下文信息，如优化级别、依赖的Pass、配置等。\nPassInfo储存了Pass的名称、描述、依赖关系等信息。\nSequential引用类\nSequentialNode储存PassInfo和Array\u0026lt;Pass\u0026gt;，实现了遍历、执行、解析依赖的功能。 在include/tvm/ir/transform.h中定义。\nCreateFunctionPass定义了函数级优化Pass CreateModulePass定义了模块级优化Pass\n","permalink":"https://KDZZZZZZ.github.io/posts/tvm%E4%BB%A3%E7%A0%81%E5%BA%93%E8%A7%A3%E6%9E%90relay%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96pass/","summary":"\u003cp\u003erelay层主要由数据结构类(如Constant)和节点类(如ConstantNode)组成。\n下面梳理一下他们的继承链。\u003c/p\u003e\n\u003cp\u003eObjectRef → BaseExpr → RelayExpr → Constant\u003c/p\u003e\n\u003cp\u003eObject → BaseExprNode → RelayExprNode → ConstantNode\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e源代码库中使用了\u003ccode\u003eusing ExprNode = tvm::RelayExprNode;\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这里先赘述一下上面每个类的的功能：\u003c/p\u003e\n\u003ch4 id=\"1-object-includetvmruntimeobjecth\"\u003e\u003cstrong\u003e(1) \u003ccode\u003eObject\u003c/code\u003e (include/tvm/runtime/object.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003eTVM \u003cstrong\u003e所有对象的基类\u003c/strong\u003e，提供 \u003cstrong\u003e引用计数\u003c/strong\u003e 和 \u003cstrong\u003e类型系统\u003c/strong\u003e 支持\u003c/li\u003e\n\u003cli\u003e实现 \u003ccode\u003eRefCount\u003c/code\u003e 机制（通过 \u003ccode\u003euse_count\u003c/code\u003e 成员）\u003c/li\u003e\n\u003cli\u003e提供 \u003ccode\u003etype_index\u003c/code\u003e 用于运行时类型识别（RTTI）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键方法\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evirtual\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint32_t\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype_index\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// 类型标识\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eIncRef\u003c/span\u003e();  \u003cspan style=\"color:#75715e\"\u003e// 增加引用计数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eDecRef\u003c/span\u003e();  \u003cspan style=\"color:#75715e\"\u003e// 减少引用计数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-objectref-includetvmruntimeobjecth\"\u003e\u003cstrong\u003e(2) \u003ccode\u003eObjectRef\u003c/code\u003e (include/tvm/runtime/object.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e所有 \u003cstrong\u003e对象引用\u003c/strong\u003e 的基类模板（如 \u003ccode\u003eConstant\u003c/code\u003e 本质是 \u003ccode\u003eObjectRef\u0026lt;ConstantNode\u0026gt;\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e通过智能指针 (\u003ccode\u003eObjectPtr\u003c/code\u003e) \u003cstrong\u003e管理 Object 子类的生命周期\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e提供 \u003cstrong\u003e类型安全转换接口\u003c/strong\u003e（如 \u003ccode\u003eas\u0026lt;T\u0026gt;()\u003c/code\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键行为\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e as() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// 安全类型转换\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ebool\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e; \u003cspan style=\"color:#75715e\"\u003e// 检查是否非空\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"3-baseexprnode-includetvmirexprh\"\u003e\u003cstrong\u003e(3) \u003ccode\u003eBaseExprNode\u003c/code\u003e (include/tvm/ir/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eObject\u003c/code\u003e → \u003ccode\u003eBaseExprNode\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e所有 \u003cstrong\u003e表达式节点\u003c/strong\u003e 的抽象基类\u003c/li\u003e\n\u003cli\u003e定义表达式通用接口：\n\u003cul\u003e\n\u003cli\u003e数据类型 (\u003ccode\u003edtype\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e源码位置 (\u003ccode\u003espan\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e虚函数 \u003ccode\u003eSEqualReduce\u003c/code\u003e（用于结构相等性比较）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键成员\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eruntime\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eDataType dtype; \u003cspan style=\"color:#75715e\"\u003e// 数据类型（如 float32）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eSpan span;               \u003cspan style=\"color:#75715e\"\u003e// 源码位置信息（用于调试）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"4-baseexpr-includetvmirexprh\"\u003e\u003cstrong\u003e(4) \u003ccode\u003eBaseExpr\u003c/code\u003e (include/tvm/ir/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eObjectRef\u003c/code\u003e → \u003ccode\u003eBaseExpr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e所有 \u003cstrong\u003e表达式引用\u003c/strong\u003e 的基类（如 \u003ccode\u003eConstant\u003c/code\u003e、\u003ccode\u003eVar\u003c/code\u003e 等）\u003c/li\u003e\n\u003cli\u003e提供对 \u003ccode\u003eBaseExprNode\u003c/code\u003e 的通用访问接口\u003c/li\u003e\n\u003cli\u003e重载运算符（如 \u003ccode\u003eoperator==\u003c/code\u003e）实现表达式比较\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"5-relayexprnode-includetvmirexprh\"\u003e\u003cstrong\u003e(5) \u003ccode\u003eRelayExprNode\u003c/code\u003e (include/tvm/ir/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eBaseExprNode\u003c/code\u003e → \u003ccode\u003eRelayExprNode\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRelay 表达式体系的节点基类\u003c/strong\u003e，定义所有高层计算图节点的通用行为\u003c/li\u003e\n\u003cli\u003e存储 Relay 特有的元数据：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e类型信息\u003c/strong\u003e (\u003ccode\u003echecked_type_\u003c/code\u003e): 类型推断后的结果（如 \u003ccode\u003eTensorType(shape=[1,3], dtype=float32)\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e源码位置\u003c/strong\u003e (\u003ccode\u003espan\u003c/code\u003e): 用于调试和错误定位\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e实现 \u003cstrong\u003e结构等价性检查\u003c/strong\u003e (\u003ccode\u003eSEqualReduce\u003c/code\u003e) 和 \u003cstrong\u003e哈希生成\u003c/strong\u003e (\u003ccode\u003eSHashReduce\u003c/code\u003e) 的虚函数\u003c/li\u003e\n\u003cli\u003e支持 \u003cstrong\u003e递归遍历子节点\u003c/strong\u003e 的接口（用于优化 Pass 或分析）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键成员\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003emutable\u003c/span\u003e Type checked_type_;  \u003cspan style=\"color:#75715e\"\u003e// 类型推断结果（可缓存）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eSpan span;                   \u003cspan style=\"color:#75715e\"\u003e// 源码位置信息\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e典型子类\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eConstantNode\u003c/code\u003e（常量）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eVarNode\u003c/code\u003e（变量）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCallNode\u003c/code\u003e（函数调用）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFunctionNode\u003c/code\u003e（函数定义）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"6-relayexpr-includetvmirexprh\"\u003e\u003cstrong\u003e(6) \u003ccode\u003eRelayExpr\u003c/code\u003e (include/tvm/ir/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eBaseExpr\u003c/code\u003e → \u003ccode\u003eRelayExpr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e通过\u003ccode\u003eTVM_DEFINE_OBJECT_REF_METHODS\u003c/code\u003e宏定义了对象引用管理、类型转换和节点访问的功能\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"7-constantnode-includetvmrelayexprh\"\u003e\u003cstrong\u003e(7) \u003ccode\u003eConstantNode\u003c/code\u003e (include/tvm/relay/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eRelayExprNode\u003c/code\u003e → \u003ccode\u003eConstantNode\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储常量数据的节点\u003c/strong\u003e（具体实现）\u003c/li\u003e\n\u003cli\u003e持有 \u003ccode\u003eruntime::NDArray\u003c/code\u003e 表示常量值\u003c/li\u003e\n\u003cli\u003e实现 \u003ccode\u003eSEqualReduce\u003c/code\u003e 比较常量值是否相等\u003c/li\u003e\n\u003cli\u003e实现 \u003ccode\u003eSHashReduce\u003c/code\u003e 生成哈希值\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键成员\u003c/strong\u003e：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eruntime\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eNDArray data; \u003cspan style=\"color:#75715e\"\u003e// 常量数据（可以是标量或张量）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"8-constant-includetvmrelayexprh\"\u003e\u003cstrong\u003e(8) \u003ccode\u003eConstant\u003c/code\u003e (include/tvm/relay/expr.h)\u003c/strong\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e继承关系\u003c/strong\u003e：\u003ccode\u003eRelayExpr\u003c/code\u003e → \u003ccode\u003eConstant\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e功能\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e用户直接使用的常量包装类\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e构造函数封装 \u003ccode\u003eConstantNode\u003c/code\u003e 的创建\u003c/li\u003e\n\u003cli\u003e提供对 \u003ccode\u003edata\u003c/code\u003e 的安全访问方法\u003c/li\u003e\n\u003cli\u003e示例用法：\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eNDArray arr \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e ...;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eConstant c \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Constant(arr);  \u003cspan style=\"color:#75715e\"\u003e// 创建常量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003eExpr expr \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e c;               \u003cspan style=\"color:#75715e\"\u003e// 可隐式转换为基类\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e有了对基类的功能认识，我们只需要继续了解类似\u003ccode\u003eConstant\u003c/code\u003e和\u003ccode\u003eConstantNode\u003c/code\u003e类的其他主要类实现。\u003c/p\u003e","title":"TVM代码库解析：Relay层结构与优化Pass"},{"content":"Welcome! Hello everyone! This is my new blog built with Hugo. I\u0026rsquo;m excited to share my thoughts and experiences here.\nWhat to Expect In this blog, I plan to write about:\nTechnology and Programming Learning experiences Personal growth Interesting projects Why I Started Blogging I believe writing is a great way to:\nOrganize thoughts Share knowledge Document learning journey Connect with like-minded people Stay tuned for more posts!\n","permalink":"https://KDZZZZZZ.github.io/posts/welcome-to-my-blog/","summary":"\u003ch2 id=\"welcome\"\u003eWelcome!\u003c/h2\u003e\n\u003cp\u003eHello everyone! This is my new blog built with Hugo. I\u0026rsquo;m excited to share my thoughts and experiences here.\u003c/p\u003e\n\u003ch3 id=\"what-to-expect\"\u003eWhat to Expect\u003c/h3\u003e\n\u003cp\u003eIn this blog, I plan to write about:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTechnology and Programming\u003c/li\u003e\n\u003cli\u003eLearning experiences\u003c/li\u003e\n\u003cli\u003ePersonal growth\u003c/li\u003e\n\u003cli\u003eInteresting projects\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"why-i-started-blogging\"\u003eWhy I Started Blogging\u003c/h3\u003e\n\u003cp\u003eI believe writing is a great way to:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOrganize thoughts\u003c/li\u003e\n\u003cli\u003eShare knowledge\u003c/li\u003e\n\u003cli\u003eDocument learning journey\u003c/li\u003e\n\u003cli\u003eConnect with like-minded people\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned for more posts!\u003c/p\u003e","title":"Welcome to My Blog"},{"content":"欢迎来到我的博客！ 这是我用 Hugo 搭建的新博客的第一篇文章。我很高兴能在这里开始分享我的想法和经历。\n期待 我会在这里写一些我感兴趣的话题。敬请期待更多内容！\n","permalink":"https://KDZZZZZZ.github.io/posts/my-first-post/","summary":"\u003ch1 id=\"欢迎来到我的博客\"\u003e欢迎来到我的博客！\u003c/h1\u003e\n\u003cp\u003e这是我用 Hugo 搭建的新博客的第一篇文章。我很高兴能在这里开始分享我的想法和经历。\u003c/p\u003e\n\u003ch2 id=\"期待\"\u003e期待\u003c/h2\u003e\n\u003cp\u003e我会在这里写一些我感兴趣的话题。敬请期待更多内容！\u003c/p\u003e","title":"我的第一篇博客"},{"content":"Oops，本科就读于杭州电子科技大学CS系28级，渴望灵感之风的吹拂也希望夯实工程能力。\n虚度的时间 探索了CS的必修四件套，go后端入门，NLP算法基础，以及一些电子元件的理论知识。还有一些比赛、外包项目。\n痛定思痛 接下来我将继续MLSys方向，同时分享一些ML和DL算法和论文复现。或许还有一些微调RAG提示词工程的笔记。靡不有初，鲜克有终。\n关于博客 理论会尽力严谨，如果有教程会尽力细致，如果有随笔会尽量随便。\nGitHub: KDZZZZZZ Email: QQ邮箱 bilibili: 在B站考研 会赢的，对吧\n","permalink":"https://KDZZZZZZ.github.io/about/","summary":"\u003cp\u003eOops，本科就读于杭州电子科技大学CS系28级，渴望灵感之风的吹拂也希望夯实工程能力。\u003c/p\u003e\n\u003ch2 id=\"虚度的时间\"\u003e虚度的时间\u003c/h2\u003e\n\u003cp\u003e探索了CS的必修四件套，go后端入门，NLP算法基础，以及一些电子元件的理论知识。还有一些比赛、外包项目。\u003c/p\u003e\n\u003ch2 id=\"痛定思痛\"\u003e痛定思痛\u003c/h2\u003e\n\u003cp\u003e接下来我将继续MLSys方向，同时分享一些ML和DL算法和论文复现。或许还有一些微调RAG提示词工程的笔记。靡不有初，鲜克有终。\u003c/p\u003e\n\u003ch2 id=\"关于博客\"\u003e关于博客\u003c/h2\u003e\n\u003cp\u003e理论会尽力严谨，如果有教程会尽力细致，如果有随笔会尽量随便。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub: \u003ca href=\"https://github.com/KDZZZZZZ\"\u003eKDZZZZZZ\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eEmail: \u003ca href=\"mailto:2112335382@qq.com\"\u003eQQ邮箱\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ebilibili: \u003ca href=\"https://space.bilibili.com/1938413314?spm_id_from=333.1007.0.0\"\u003e在B站考研\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e会赢的，对吧\u003c/p\u003e","title":"About Me"},{"content":"Hello, World! This is my first blog post. Here, I\u0026rsquo;ll share some interesting tech insights and life experiences.\nWhy Start a Blog? Blogging helps me:\nDocument my learning journey Share technical insights Connect with like-minded people Future Plans I plan to write about:\nProgramming techniques Learning experiences Life reflections Stay tuned!\n","permalink":"https://KDZZZZZZ.github.io/posts/hello-world/","summary":"\u003ch2 id=\"hello-world\"\u003eHello, World!\u003c/h2\u003e\n\u003cp\u003eThis is my first blog post. Here, I\u0026rsquo;ll share some interesting tech insights and life experiences.\u003c/p\u003e\n\u003ch3 id=\"why-start-a-blog\"\u003eWhy Start a Blog?\u003c/h3\u003e\n\u003cp\u003eBlogging helps me:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDocument my learning journey\u003c/li\u003e\n\u003cli\u003eShare technical insights\u003c/li\u003e\n\u003cli\u003eConnect with like-minded people\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"future-plans\"\u003eFuture Plans\u003c/h3\u003e\n\u003cp\u003eI plan to write about:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProgramming techniques\u003c/li\u003e\n\u003cli\u003eLearning experiences\u003c/li\u003e\n\u003cli\u003eLife reflections\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eStay tuned!\u003c/p\u003e","title":"Hello World"},{"content":"TVM Relay IR Optimization Methods 优化方法概述 本文档详细介绍了TVM Relay IR中实现的各种优化方法。每个优化方法都包含其数学原理、算法实现和实际应用示例。这些优化方法共同构成了TVM的优化体系,旨在提高深度学习模型的执行效率。\nTable of Contents TVM Relay IR Optimization Methods 优化方法概述 Table of Contents 1. dead_code.cc - 死代码消除 细化 2. eliminate_common_subexpr.cc - 公共子表达式消除 细化 3. fold_constant.cc - 常量折叠 细化 4. fuse_ops.cc - 算子融合优化 细化 5. transform_layout.h, convert_layout.cc - 布局转换 细化 6. type_infer.cc - 类型推断 细化 7. to_a_normal_form.cc - A-范式转换 细化 8. to_graph_normal_form.cc - 图范式转换 细化 9. partial_eval.cc - 部分求值 细化 10. loop_partition.cc - 循环分块优化 细化 11. loop_unroll.cc - 循环展开 细化 12. loop_vectorize.cc - 循环向量化 细化 13. memory_promotion.cc - 内存提升优化 细化 14. simplify_expr.cc - 表达式简化 细化 15. storage_rewrite.cc - 存储重写优化 细化 16. parallelize.cc - 并行化优化 细化 17. memory_alloc.cc - 内存分配优化 细化 18. dataflow_analysis.cc - 数据流分析 细化 19. loop_invariant.cc - 循环不变式外提 细化 20. bound_check_eliminate.cc - 边界检查消除 细化 21. common_subexp_eliminate.cc - 公共子表达式消除 细化 22. dead_code_eliminate.cc - 死代码消除 细化 23. strength_reduction.cc - 强度消减 细化 24. register_allocate.cc - 寄存器分配 细化 25. vectorize.cc - 向量化优化 细化 26. loop_unroll.cc - 循环展开优化 细化 27. inline_expand.cc - 内联展开优化 细化 28. const_propagation.cc - 常量传播优化 细化 29. alias_analysis.cc - 别名分析 细化 31. mem2reg.cc - 内存到寄存器提升 细化 32. gvn.cc - 全局值编号 细化 33. loop_fusion.cc - 循环融合优化 细化 34. loop_tiling.cc - 循环分块优化 细化 35. tail_call_opt.cc - 尾调用优化 细化 36. autovectorize.cc - 自动向量化 细化 37. dead_store_elim.cc - 死存储消除优化 细化 38. strength_reduction.cc - 强度削减优化 细化 39. register_alloc.cc - 寄存器分配优化 细化 40. inline_expansion.cc - 内联展开优化 细化 41. loop_unswitch.cc - 循环不变量外提优化 细化 42. instruction_combine.cc - 指令组合优化 细化 43. const_propagate.cc - 常量传播优化 细化 44. cse.cc - 公共子表达式消除 细化 45. dce.cc - 死代码消除优化 细化 46. licm.cc - 循环不变代码外提优化 细化 47. loop_fusion.cc - 循环融合优化 细化 48. loop_peeling.cc - 循环剥离优化 细化 49. vectorization.cc - 自动向量化优化 细化 50. loop_tiling.cc - 循环分块优化 细化 51. tail_call.cc - 尾调用优化 细化 1. dead_code.cc - 死代码消除 细化 优化目的:\n删除程序中永远不会执行的代码 消除无效的计算和未使用的变量定义 减少程序体积,提高执行效率 应用场景:\n条件分支简化后产生的不可达代码 局部变量定义后未使用 计算结果未被使用的表达式 活跃变量分析数学原理:\n数据流方程推导: 对于基本块B,定义: \\begin{aligned} IN[B] \u0026amp;= \\bigcup_{S \\in succ(B)} OUT[S] \\\\ OUT[B] \u0026amp;= GEN[B] \\cup (IN[B] \\setminus KILL[B]) \\end{aligned} 迭代求解直到收敛,其中: $GEN[B]$: 块B中定义的变量集合 $KILL[B]$: 块B中被重新定义的变量集合 控制流图构建算法:\ndef build_cfg(expr): cfg = CFG() current_block = BasicBlock() for node in post_order_visit(expr): if isinstance(node, ControlOp): cfg.add_edge(current_block, node.true_branch) cfg.add_edge(current_block, node.false_branch) current_block = BasicBlock() else: current_block.add(node) return cfg 消除条件证明:\n不可达代码定理: 设程序入口为$B_0$,当且仅当存在路径$B_0 \\rightarrow^* B$时,块B为可达。通过深度优先遍历可达性集合: Reachable = \\{B_0\\} \\cup \\bigcup_{B \\in Reachable} succ(B) 2. eliminate_common_subexpr.cc - 公共子表达式消除 细化 优化目的:\n避免重复计算相同的表达式 利用已计算结果减少冗余运算 降低计算开销,提高执行效率 应用场景:\n循环中重复出现的复杂计算 多处使用相同表达式的代码 编译器自动优化的关键手段 表达式规范化算法:\n规范形式转换: 交换律重排: $a + b \\rightarrow b + a$ (按操作数哈希排序) 结合律展开: $(a + b) + c \\rightarrow a + b + c$ def canonicalize(expr): if is_commutative(expr.op): args = sorted(expr.args, key=hash) return expr.op(*args) elif is_associative(expr.op): return flatten_assoc(expr) return expr 哈希表设计:\n表达式指纹计算: 采用Merkle树结构哈希: hash(e) = hash(op) \\oplus \\bigoplus_{arg \\in args} hash(arg) 其中$\\oplus$为按位异或,保证交换律操作的哈希不变性 替换策略数学证明:\n语义等价性条件: 两个表达式$e_1,e_2$可替换当且仅当: \\forall \\sigma \\in \\Sigma, \\llbracket e_1 \\rrbracket_\\sigma = \\llbracket e_2 \\rrbracket_\\sigma 其中$\\sigma$为程序状态,$\\llbracket \\cdot \\rrbracket$为求值函数 3. fold_constant.cc - 常量折叠 细化 优化目的:\n在编译期计算常量表达式 减少运行时计算开销 为其他优化创造条件 应用场景:\n数值常量的算术运算 条件表达式中的常量判断 数组索引的常量计算 常量传播格理论:\n格结构定义: 设值域为$L = \\top \\cup \\mathbb{Z} \\cup {\\bot}$,其中: $\\top$: 未知值 $\\bot$: 冲突值 偏序关系: $\\bot \\sqsubseteq x \\sqsubseteq \\top$ 符号执行规则:\ndef eval(expr, env): if isinstance(expr, Var): return env.get(expr, TOP) elif isinstance(expr, Add): a = eval(expr.a, env) b = eval(expr.b, env) if a in Z and b in Z: return a + b elif a == BOT or b == BOT: return BOT else: return TOP # 扩展其他操作规则 折叠条件判定:\n完全折叠条件: \\frac{\\forall v \\in vars(e), \\sigma(v) \\neq \\top \\land \\sigma(v) \\neq \\bot}{e \\downarrow} 其中$e \\downarrow$表示表达式可折叠为常量 边界处理算法:\ntemplate\u0026lt;typename T\u0026gt; T safe_fold(Expr e) { try { return evaluate(e); } catch (const DivisionByZero\u0026amp;) { insert_assertion(e.denominator != 0); return e; // 保留原表达式并插入运行时检查 } } 4. fuse_ops.cc - 算子融合优化 细化 优化目的:\n合并相邻的算子以减少计算开销 提高执行效率和缓存局部性 应用场景:\n相邻的算子操作相同的数据 循环体内的算子融合 算子依赖图建模:\n计算图可达性分析: 定义算子间数据依赖关系为有向边,构造邻接矩阵$A$: A_{ij} = \\begin{cases} 1 \u0026amp; \\text{算子}i\\text{的输出是算子}j\\text{的输入} \\\\ 0 \u0026amp; \\text{否则} \\end{cases} 可达性矩阵$R$通过Warshall算法计算: R = \\bigvee_{k=1}^n A^{[k]} \\quad \\text{其中} A^{[k]} = A^{[k-1]} \\vee (A^{[k-1]} \\cdot A) 融合收益模型:\n内存访问成本公式: $$ C_{mem} = \\sum_{t}(T_{load}(d_t) + T_{store}(d_t)) $$\n$d_t$: 数据张量大小 $T_{load}$/$T_{store}$: 内存层级访问延迟(如L1: 1 cycle, DRAM: 200 cycles) 计算强度比: $$ R = \\frac{\\text{总FLOPs}}{\\text{总字节数}} $$ 当$R \u0026gt; R_{threshold}$时判定为计算密集型,适合融合\n子图同构检测算法:\nclass FusionPatternMatcher { vector\u0026lt;OpPattern\u0026gt; patterns; // 预定义融合模板 bool match_subgraph(Graph g, OpPattern p) { if (g.ops.size() != p.size()) return false; return VF2SubgraphIsomorphism(g, p).is_match(); // VF2算法实现 } void find_fusion_candidates() { for (auto\u0026amp; pattern : patterns) { for (auto\u0026amp; subg : enumerate_subgraphs()) { if (match_subgraph(subg, pattern)) { mark_for_fusion(subg); } } } } }; 5. transform_layout.h, convert_layout.cc - 布局转换 细化 优化目的:\n优化数据布局以提高缓存局部性 提高执行效率和数据访问性能 应用场景:\n大规模数据处理 高性能计算 张量布局代数:\n布局变换矩阵: 定义存储顺序为排列矩阵$P \\in {0,1}^{n×n}$,例如NHWC→NCHW转换: P = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} 变换后张量$T\u0026rsquo; = T \\cdot P$,其中$\\cdot$表示张量维置换 数据局部性优化:\n缓存行对齐公式: 要求转换后张量维度满足: \\prod_{i=k}^n d_i \\equiv 0 \\mod (cache\\_line\\_size / sizeof(dtype)) 其中$k$为最外层连续维度索引 自动布局转换算法:\ndef auto_layout_transform(tensor, target_layout): # 计算当前布局与目标布局的维度映射 src_dims = get_dimension_permutation(tensor.layout) tgt_dims = get_dimension_permutation(target_layout) perm = compute_permutation(src_dims, tgt_dims) # 插入转置操作 transposed = transpose(tensor, perm) # 优化连续内存访问 if not is_contiguous(transposed): return copy_to_contiguous(transposed) return transposed 6. type_infer.cc - 类型推断 细化 优化目的:\n自动推断变量类型以减少显式类型注解 提高代码可读性和编程效率 应用场景:\n动态类型语言 高级编程语言 类型格理论:\n类型提升规则: 定义类型偏序关系$\\sqsubseteq$: \\text{bool} \\sqsubseteq \\text{int8} \\sqsubseteq \\text{int16} \\sqsubseteq \\text{int32} \\sqsubseteq \\text{int64} \\sqsubseteq \\text{float32} \\sqsubseteq \\text{float64} 最小上界(LUB)计算: \\text{LUB}(t1, t2) = \\min\\{ t \\in T | t1 \\sqsubseteq t \\land t2 \\sqsubseteq t \\} 约束传播算法:\nclass TypeInferencer: def visit_expr(self, expr): for arg in expr.args: self.visit(arg) # 收集子表达式类型约束 constraints = collect_constraints(expr) # 解约束方程组 solution = solve_constraints(constraints) expr.type = solution[expr] def solve_constraints(constraints): # 使用Union-Find算法合并等价类 uf = UnionFind() for t1, rel, t2 in constraints: if rel == \u0026#39;EQ\u0026#39;: uf.union(t1, t2) elif rel == \u0026#39;LE\u0026#39;: uf.merge(t1, t2, lambda a,b: max(a,b)) return uf.get_types() 7. to_a_normal_form.cc - A-范式转换 细化 优化目的:\n将表达式转换为A-范式以提高执行效率 减少计算开销和内存访问 应用场景:\n高性能计算 科学计算 λ演算规范化原理:\nANF形式化定义: 任何表达式$e$可转换为: e \\Rightarrow \\text{let}~x = e_1~\\text{in}~e_2 \\quad \\text{或} \\quad v 其中$e_1$为原子表达式,$e_2$为ANF形式,$v$为值(变量/常量) 控制流扁平化算法:\ndef to_anf(expr): if is_atomic(expr): return expr temp_vars = [] def walk(e): if is_atomic(e): return e new_e = reconstruct(walk, e) if not is_anf_form(new_e): var = fresh_var() temp_vars.append( (var, new_e) ) return var return new_e body = walk(expr) for var, val in reversed(temp_vars): body = Let(var, val, body) return body 8. to_graph_normal_form.cc - 图范式转换 细化 优化目的:\n将表达式转换为图范式以提高执行效率 减少计算开销和内存访问 应用场景:\n高性能计算 科学计算 数据流图构建:\n使用定义-引用链: 构造图节点集合$V = { v | v \\in vars(expr) }$,边集合: E = \\{ (v_i, v_j) | v_j \\in refs(def(v_i)) \\} $def(v)$: 变量v的定义点 $refs(e)$: 表达式e引用的变量集合 公共路径压缩算法:\nGraph compress_graph(Graph g) { for (auto v : g.nodes) { if (v.out_degree() == 1 \u0026amp;\u0026amp; g[v].out_nodes[0].in_degree() == 1) { merge_nodes(v, v.out_nodes[0]); // 合并线性链节点 } } return remove_identity_nodes(g); // 移除单位矩阵类操作 } 9. partial_eval.cc - 部分求值 细化 优化目的:\n在编译期求值部分表达式以减少运行时计算 提高执行效率和代码可读性 应用场景:\n动态类型语言 高级编程语言 部分求值格理论:\n三值抽象域: $$ \\mathbb{D} = { \\bot, \\top, \\text{Concrete}(v) } $$ 其中: $\\bot$: 不可计算 $\\top$: 可能为任意值 $\\text{Concrete}(v)$: 已知具体值 符号执行引擎:\nclass PartialEvaluator: def visit(self, expr, env): if expr in env: return env[expr] res = self.generic_visit(expr, env) if all(arg.is_concrete() for arg in res.args): return Constant(fold(res)) # 完全求值 elif any(arg.is_top() for arg in res.args): return expr.with_type(res.type) # 保留符号形式 else: return MixedExpr(res) # 混合表达式 10. loop_partition.cc - 循环分块优化 细化 优化目的:\n将循环分块以提高缓存局部性和执行效率 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 分块尺寸计算原理:\n缓存容量约束: 设缓存行大小为$C$,数组元素大小为$s$,则最优分块尺寸$B$满足: B = \\left\\lfloor \\sqrt{\\frac{C \\times L}{s \\times k}} \\right\\rfloor $L$: 缓存层级容量(L1/L2) $k$: 数组访问维度数(如二维数组k=2) 数据局部性优化:\n跨步访问消除: 分块后内存访问模式满足: \\forall i,j \\in [0,B), \\frac{|addr(i+1,j) - addr(i,j)|}{s} \\leq cache\\_line\\_size 循环重组算法:\nvoid tiling_transform(LoopNode* loop) { int B = compute_tile_size(loop); // 计算分块尺寸 auto [i_outer, i_inner] = split_loop(loop-\u0026gt;index, B); auto [j_outer, j_inner] = split_loop(loop-\u0026gt;nest-\u0026gt;index, B); reorder_loops({i_outer, j_outer, i_inner, j_inner}); // 重组循环顺序 update_access_pattern(loop-\u0026gt;body); // 更新内存访问模式 } 11. loop_unroll.cc - 循环展开 细化 优化目的:\n将循环展开以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 展开因子选择模型:\n寄存器压力约束: 最大展开因子$J_{max}$满足: J_{max} = \\left\\lfloor \\frac{R_{total} - R_{used}}{R_{unroll}} \\right\\rfloor $R_{total}$: 目标架构寄存器总数 $R_{used}$: 循环体内已用寄存器数 $R_{unroll}$: 单次迭代新增寄存器需求 指令级并行优化:\n依赖链长度分析: 设最长依赖链长度为$D$, 则最小展开因子: J_{min} = \\lceil D / issue\\_width \\rceil $issue_width$: CPU发射宽度(如4-way) 展开代码生成:\n; 原始循环: %i = phi i32 [ 0, %entry ], [ %i.next, %loop ] ; 展开4次后: %i.1 = add i32 %i, 1 %i.2 = add i32 %i, 2 %i.3 = add i32 %i, 3 %i.next = add i32 %i, 4 br i1 %exit.cond, label %exit, label %loop 12. loop_vectorize.cc - 循环向量化 细化 优化目的:\n将循环向量化以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 向量化因子选择:\nSIMD位宽匹配: 向量化因子$V$由SIMD寄存器宽度决定: V = \\frac{register\\_bits}{element\\_bits} 例如float32+AVX512: $V=512/32=16$ 数据对齐分析:\n地址对齐条件: 数组基地址满足: addr(a) \\mod (V \\times element\\_size) = 0 若不满足则生成前导标量循环处理未对齐部分 自动向量化算法:\nbool auto_vectorize(Loop loop) { if (!check_simd_conditions(loop)) return false; // 依赖关系检查 auto dep_result = analyze_dependencies(loop); if (dep_result.has_loop_carried) return false; // 生成向量化代码 int V = target_simd_width / loop.elem_type.bits(); auto vloop = create_vector_loop(loop, V); if (loop.trip_count % V != 0) { add_epilogue_loop(loop, V); // 处理尾部迭代 } replace_loop(loop, vloop); return true; } 13. memory_promotion.cc - 内存提升优化 细化 优化目的:\n将内存提升为寄存器以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 数据生命周期分析:\n活性区间计算: 对每个内存对象$m$,定义其活性区间为: [t_{def}, t_{last\\_use}] $t_{def}$: 首次定义时间步 $t_{last_use}$: 最后使用时间步 寄存器提升条件:\n局部性条件: \\frac{t_{last\\_use} - t_{def}}{size(m)} \u0026lt; \\frac{R_{free}}{W_{loop}} $R_{free}$: 可用寄存器数量 $W_{loop}$: 循环体权重因子 14. simplify_expr.cc - 表达式简化 细化 优化目的:\n简化表达式以提高执行效率和代码可读性 减少计算开销和内存访问 应用场景:\n动态类型语言 高级编程语言 代数恒等式重写:\n强度消减规则: \\frac{}{a \\times 2^n \\Rightarrow a \\ll n} \\quad \\text{(当a为整数类型时)} 常量传播算法:\nValue const_propagate(Expr e) { if (auto op = e.as\u0026lt;BinaryOp\u0026gt;()) { if (is_const(op-\u0026gt;left) \u0026amp;\u0026amp; is_const(op-\u0026gt;right)) { return eval_const_expr(op); } } return fold_constants(e); // 部分常量折叠 } 15. storage_rewrite.cc - 存储重写优化 细化 优化目的:\n优化存储布局以提高缓存局部性和执行效率 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 内存布局转换:\n行优先转列优先: 转换后的访问模式满足: addr_{new}(i,j) = addr_{base} + i \\times C + j \\times R $R$: 原始行数 $C$: 原始列数 原地更新验证:\n别名分析定理: \\forall i,j,\\quad \\text{may\\_alias}(a[i], b[j]) \\Rightarrow \\text{safe\\_to\\_overlap}(a,b) = \\text{false} 16. parallelize.cc - 并行化优化 细化 优化目的:\n将循环并行化以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 任务划分模型:\n负载均衡公式: 设总工作量$W$,线程数$P$,则每个线程分配量: \\text{chunk}_i = \\left\\lfloor \\frac{W}{P} \\right\\rfloor + \\begin{cases} 1 \u0026amp; i \u0026lt; W \\mod P \\\\ 0 \u0026amp; \\text{否则} \\end{cases} 依赖关系分析:\nBernstein条件: 两个任务可并行当且仅当: (R_1 \\cap W_2) \\cup (W_1 \\cap R_2) \\cup (W_1 \\cap W_2) = \\emptyset $R_i$: 任务i的读集 $W_i$: 任务i的写集 并行代码生成:\n#pragma omp parallel for schedule(dynamic, chunk_size) for (int i = 0; i \u0026lt; N; ++i) { // 并行化循环体 process(data[i]); } 17. memory_alloc.cc - 内存分配优化 细化 优化目的:\n优化内存分配以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 伙伴系统算法:\n块分裂条件: 当请求大小$s$满足: 2^{k-1} \u0026lt; s \\leq 2^k \\quad\\Rightarrow\\quad \\text{分裂块直到尺寸} 2^k $k$为满足$2^k \\geq s$的最小整数 内存碎片评估:\n外部碎片率: F = 1 - \\frac{\\sum \\text{已用块大小}}{\\text{总空闲内存}} 当$F \u0026gt; 0.3$时触发碎片整理 18. dataflow_analysis.cc - 数据流分析 细化 优化目的:\n分析数据流以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 活跃变量分析:\n数据流方程: \\begin{aligned} IN[B] \u0026amp;= \\bigcup_{S \\in succ(B)} OUT[S] \\\\ OUT[B] \u0026amp;= GEN[B] \\cup (IN[B] \\setminus KILL[B]) \\end{aligned} $GEN[B]$: 基本块B生成的变量 $KILL[B]$: 基本块B杀死的变量 迭代求解算法:\ndef solve_dataflow(): changed = True while changed: changed = False for block in reverse_postorder: old_in = in_[block] in_[block] = union(out[p] for p in predecessors(block)) out[block] = gen[block] | (in_[block] - kill[block]) if in_[block] != old_in: changed = True 19. loop_invariant.cc - 循环不变式外提 细化 优化目的:\n将循环不变式外提以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 不变式检测原理:\n循环封闭条件: 表达式$e$可外提当满足: \\forall v \\in vars(e),\\quad def(v) \\cap loop\\_body = \\emptyset \\quad \\land \\quad \\phi\\text{-free}(e) $\\phi\\text{-free}$: 不含循环携带的phi函数 安全外提定理:\n支配性验证: 外提位置$L$需满足: L \\preceq all\\_exit\\_points(loop) \\quad \\land \\quad L \\succeq all\\_entry\\_points(loop) 其中$\\preceq$表示控制流支配关系 外提算法:\n; 原始循环: loop: %a = add i32 %x, 5 ; 循环不变式 %b = mul i32 %a, %iter ; 依赖迭代变量 ; 优化后: %a.lifted = add i32 %x, 5 ; 外提到前置块 preheader: br label %loop loop: %b = mul i32 %a.lifted, %iter 20. bound_check_eliminate.cc - 边界检查消除 细化 优化目的:\n消除边界检查以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 范围传播分析:\n区间代数: 变量$v$的值域表示为$[l, u]$, 验证数组访问$a[i]$安全的条件: l \\geq 0 \\quad \\land \\quad u \u0026lt; len(a) \\quad \\land \\quad \\forall k \\in [l, u],\\ type(a[k]) \\neq undefined 守卫条件融合:\nif (i \u0026lt; a_len) { // 显式检查 if (j \u0026lt; b_len) { // 隐式推导 access(a[i], b[j]); // 安全检查消除 } } // 优化后: access(a[i], b[j]); // 验证i∈[0,a_len) ∧ j∈[0,b_len) 21. common_subexp_eliminate.cc - 公共子表达式消除 细化 优化目的:\n消除公共子表达式以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 表达式哈希技术:\n规范形式转换: 建立表达式指纹: hash(e) = \\text{SHA1}(op \\| hash(e_1) \\| \\cdots \\| hash(e_n)) 其中操作数按规范顺序排列(如按变量名排序交换律操作数) 值编号优化:\n// 原始代码: double x = a*b + c; double y = a*b + d; // 优化后: double t1 = a*b; double x = t1 + c; double y = t1 + d; 22. dead_code_eliminate.cc - 死代码消除 细化 优化目的:\n消除死代码以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 活跃性判定准则:\n副作用传播规则: 语句$S$不可删除当满足: \\exists v \\in S.\\text{defs},\\ v \\in \\text{LIVE-OUT}(B) \\quad \\lor \\quad S\\ \\text{has observable side effects} LIVE-OUT(B):基本块出口处的活跃变量集合 控制流相关死代码:\n不可达路径分析: 使用区间分析验证条件分支的必然性: \\text{if } cond \\text{ then } T \\text{ else } F \\quad \\Rightarrow \\quad \\text{Prune}(F) \\text{ if } cond \\equiv \\text{true} 23. strength_reduction.cc - 强度消减 细化 优化目的:\n减少强度以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 归纳变量优化:\n线性表达式替换: 对循环索引$i$的乘法运算,转换为加法形式: i = i_{init} + k \\cdot step \\quad \\Rightarrow \\quad x = x_{init} + k \\cdot (step \\times coeff) 其中$coeff$为原表达式的乘法系数 代价模型公式: 替换操作的收益需满足:\n\\frac{C_{\\text{original}} - C_{\\text{reduced}}}{C_{\\text{original}}} \\geq \\theta_{\\text{threshold}} $\\theta_{\\text{threshold}}$通常设置为0.2(20%性能提升阈值)\n24. register_allocate.cc - 寄存器分配 细化 优化目的:\n优化寄存器分配以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 图着色模型:\n冲突图构建: 变量$v_i$与$v_j$存在边当: \\exists \\text{LiveRange}(v_i) \\cap \\text{LiveRange}(v_j) \\neq \\emptyset \\quad \\land \\quad \\text{Size}(v_i) + \\text{Size}(v_j) \u0026gt; \\text{RegSize} 溢出代价计算: 变量$v$的溢出代价:\n\\text{SpillCost}(v) = \\sum_{u \\in \\text{uses}(v)} 10^{loop\\_depth(u)} + 5 \\times \\text{is\\_address\\_operand}(u) 深度越大的循环中使用的变量优先级越高\n25. vectorize.cc - 向量化优化 细化 优化目的:\n向量化以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 数据并行性检测:\n循环向量化条件: 循环可向量化当满足: \\forall i,\\ \\text{distance}(a[i], a[i+1]) = \\text{align\\_size} \\quad \\land \\quad \\text{no\\_loop\\_carried\\_dependence} align_size 为向量寄存器宽度对齐要求 loop_carried_dependence 需通过依赖图的强连通分量分析验证 SIMD指令生成:\n; 标量加法: for (i=0; i\u0026lt;4; i++) c[i] = a[i] + b[i]; ; 向量化后: %vec_a = load \u0026lt;4 x float\u0026gt;, ptr %a %vec_b = load \u0026lt;4 x float\u0026gt;, ptr %b %vec_c = fadd \u0026lt;4 x float\u0026gt; %vec_a, %vec_b store \u0026lt;4 x float\u0026gt; %vec_c, ptr %c 26. loop_unroll.cc - 循环展开优化 细化 优化目的:\n循环展开以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 展开因子选择:\n开销收益模型: 最优展开因子$k$满足: k = \\arg\\max_{1 \\leq k \\leq U_{\\text{max}}} \\left( \\frac{T_{\\text{理论}} \\cdot k}{\\text{RegisterPressure}(k)} \\right) $U_{\\text{max}}$ 由目标架构的寄存器数量限制。 余数处理策略:\n// 完全展开示例 for (int i=0; i\u0026lt;N; i+=4) { process(i); // 主迭代 if (i+1\u0026lt;N) process(i+1); // 尾部处理 if (i+2\u0026lt;N) process(i+2); if (i+3\u0026lt;N) process(i+3); } 27. inline_expand.cc - 内联展开优化 细化 优化目的:\n内联展开以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 内联决策模型:\n综合代价评估: 函数$f$可内联的条件需满足: \\text{InlineScore} = \\alpha \\cdot \\text{CallOverhead} - \\beta \\cdot \\text{CodeSizeDelta} - \\gamma \\cdot \\text{RegisterPressure} \u0026gt; \\text{Threshold} $\\alpha, \\beta, \\gamma$ 为架构相关权重因子 调用开销包含参数传递、栈帧构建等 递归内联约束: 递归调用内联深度$d$满足:\nd \\leq \\left\\lfloor \\frac{\\text{MaxRecursiveInlineDepth}}{\\text{RecursionComplexity}(f)} \\right\\rfloor 复杂度通过函数CFG的环路数和状态数计算 28. const_propagation.cc - 常量传播优化 细化 优化目的:\n常量传播以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 数据流方程:\n传递函数: 对基本块$B$中的每个语句$s: x = e$, 常量传播的更新规则为: OUT[B] = (IN[B] \\setminus \\{(x, \\_)\\}) \\cup \\{(x, v)\\} \\quad \\text{其中} \\quad v = \\begin{cases} \\text{eval}(e, IN[B]) \u0026amp; \\text{if } e \\text{ 可静态求值} \\\\ \\top \u0026amp; \\text{否则} \\end{cases} $\\top$表示非常量状态 $\\text{eval}$在常量环境下求值表达式 条件常量传播:\n; 原始代码: %cond = icmp eq i32 %x, 42 br i1 %cond, label %true, label %false ; 若%x在数据流分析中恒等于42, 可优化为: br label %true 29. alias_analysis.cc - 别名分析 细化 优化目的:\n别名分析以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 基于类型的别名规则:\n访问冲突判定: 两个指针$p,q$不会互为别名当满足: \\exists T_1, T_2 \\in \\text{Type},\\quad T_1 \\neq T_2 \\quad \\land \\quad \\text{alignof}(T_1) \\neq \\text{alignof}(T_2) 流敏感别名分析:\n指针状态转移方程: \\text{After } p = \\\u0026amp;x \\quad\\Rightarrow\\quad \\text{MustAlias}(p, x) \\quad\\land\\quad \\neg\\text{MayAlias}(p, q \\neq p) \\text{After } p = q \\quad\\Rightarrow\\quad \\text{AliasSet}(p) = \\text{AliasSet}(q) 30. licm.cc - 循环不变代码外提 细化 优化目的:\n循环不变代码外提以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 循环不变式条件:\n表达式$e$可外提当且仅当:\n\\forall v \\in \\text{operands}(e),\\quad \\text{def}(v) \\cap \\text{loop\\_body} = \\emptyset \\quad \\land \\quad \\text{volatile\\_free}(e) 安全外提约束:\n表达式执行不能有副作用: \\text{SideEffect}(e) = \\emptyset \\ \\land \\ \\text{ExceptionFree}(e) 若循环可能不执行(如 while 循环),需插入保护条件: if (loop_condition) { // 外提后的代码 // 原循环体 } 31. mem2reg.cc - 内存到寄存器提升 细化 优化目的:\n内存到寄存器提升以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 Promotion Criteria:\n单一定义规则: 内存位置可提升为寄存器当满足:\n\\forall p \\in \\text{PointerTo}(alloc),\\quad \\text{MayAlias}(p, alloc) \\implies \\text{UseDefChain}(p) \\text{ is singleton} 确保该内存位置的所有访问均无歧义别名 SSA构造算法:\nPhi节点插入策略: 在控制流交汇点插入Φ函数,满足: \\forall v \\in \\text{Var},\\quad \\Phi(v) = \\bigcup_{pred \\in Predecessors} \\text{LatestDef}(v, pred) 采用迭代数据流分析确定支配边界 32. gvn.cc - 全局值编号 细化 优化目的:\n全局值编号以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 同值类划分:\n值等价关系: 定义操作等价性: op_1 \\equiv op_2 \\iff \\text{opcode}(op_1) = \\text{opcode}(op_2) \\land \\bigwedge_i \\text{VN}(operand_i(op_1)) = \\text{VN}(operand_i(op_2)) VN为值编号函数 冗余消除:\n; 冗余存储示例: store i32 %x, ptr @g call void @foo() store i32 %x, ptr @g ; 可消除 ; 优化后: store i32 %x, ptr @g call void @foo() 33. loop_fusion.cc - 循环融合优化 细化 优化目的:\n循环融合以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 融合合法性检查:\n依赖关系检查: 循环L1与L2可融合当满足: \\text{DependenceDistance}(L_1, L_2) \\geq 0 \\quad \\land \\quad \\text{IterationSpace}(L_1) \\equiv \\text{IterationSpace}(L_2) 收益模型: 融合后的性能增益计算:\n\\text{Gain} = (T_{\\text{loop\\_overhead}} \\times (n-1)) - T_{\\text{fused\\_loop\\_overhead}} - \\Delta T_{\\text{cache\\_miss}} n为原始循环个数 考虑缓存局部性改善带来的负收益 34. loop_tiling.cc - 循环分块优化 细化 优化目的:\n循环分块以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 分块尺寸选择: 最优分块尺寸 $T$ 通过最小化缓存未命中率:\nT = \\sqrt{\\frac{\\text{CacheSize}}{\\text{ElementSize} \\cdot N_{\\text{dim}}}} 多维循环需满足各维度分块乘积不超过缓存容量 数据局部性提升: 分块后数据复用率满足:\n\\text{ReuseRatio} = \\frac{\\text{BlockIterations}}{\\text{MemoryAccesses}} \\geq \\text{ReuseThreshold} 对矩阵乘法等计算密集型循环,分块可提升 L1/L2 缓存命中率 35. tail_call_opt.cc - 尾调用优化 细化 优化目的:\n尾调用优化以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 尾调用识别条件: 函数调用$f(x)$可优化为尾调用当满足:\n\\text{CallSite}(f) \\equiv \\text{ReturnSite}(current) \\quad \\land \\quad \\text{StackFrameReusable}(current, f) 栈帧复用约束:\n\\text{FrameSize}(caller) \\leq \\text{FrameSize}(callee) \\ \\land \\ \\text{ParameterAlignment} \\equiv 0 \\pmod{\\text{WordSize}} 若被调用者栈帧更大,需插入栈调整指令或放弃优化 36. autovectorize.cc - 自动向量化 细化 优化目的:\n自动向量化以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 向量化可行性分析:\n步长对齐条件: \\text{Stride}(access) = \\pm 1 \\quad \\lor \\quad (\\text{Stride} \\bmod \\text{VectorWidth}) = 0 混洗指令优化:\n; 非连续访问模式: %v = shufflevector \u0026lt;4 x float\u0026gt; %a, \u0026lt;4 x float\u0026gt; %b, \u0026lt;4 x i32\u0026gt; \u0026lt;i32 3, i32 2, i32 1, i32 0\u0026gt; ; 对应 AVX 指令: vpermilps $0x1b, %xmm0, %xmm1 37. dead_store_elim.cc - 死存储消除优化 细化 优化目的:\n死存储消除以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 存储有效性分析:\n覆盖链检测: 存储指令 $S_i: \\text{store } v \\text{ to } p$ 可消除当存在后续存储 $S_j$ 满足: \\text{Reach}(S_i, S_j) \\land \\text{NoAlias}(p, S_k) \\quad \\forall S_k \\in \\text{Path}(S_i, S_j) 跨过程分析:\n副作用追踪: 若函数 $f$ 被标记为 pure 或 readonly, 则其调用点前后存储状态满足:\n\\text{ModRef}(f) \\cap \\text{AliveStores} = \\emptyset 38. strength_reduction.cc - 强度削减优化 细化 优化目的:\n强度削减以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 归纳变量替换:\n线性表达式替换: 对循环变量 $i$ 的表达式 $e = a \\times i + b$ 可替换为: e\u0026#39; = e_{\\text{prev}} + a \\quad \\text{where} \\quad \\Delta i = 1 要求满足: \\forall \\text{iter}, \\frac{\\partial e}{\\partial i} = \\text{const} 代价模型: 替换可行性判定:\n\\text{Benefit} = \\sum_{\\text{use}} (\\text{Cycle}_{\\text{original}} - \\text{Cycle}_{\\text{reduced}}) \u0026gt; \\text{SetupCost} 39. register_alloc.cc - 寄存器分配优化 细化 优化目的:\n寄存器分配以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 图着色模型:\n冲突图构建: 变量$v_i$与$v_j$存在边当: \\exists \\text{LiveRange}(v_i) \\cap \\text{LiveRange}(v_j) \\neq \\emptyset \\quad \\land \\quad \\text{Size}(v_i) + \\text{Size}(v_j) \u0026gt; \\text{RegSize} 溢出代价计算: 选择溢出变量 $v$ 的准则:\n\\arg\\min_{v} \\left( \\frac{\\text{UseCount}(v)}{\\text{Size}(v)} \\times \\text{SpillCostWeight} \\right) 40. inline_expansion.cc - 内联展开优化 细化 优化目的:\n内联展开以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 内联收益模型:\n综合代价评估: 函数$f$可内联的条件需满足: \\text{InlineScore} = \\alpha \\cdot \\text{CallOverhead} - \\beta \\cdot \\text{CodeSizeDelta} - \\gamma \\cdot \\text{RegisterPressure} \u0026gt; \\text{Threshold} $\\alpha, \\beta, \\gamma$ 为架构相关权重因子 调用开销包含参数传递、栈帧构建等 递归内联约束: 递归调用内联深度$d$满足:\nd \\leq \\left\\lfloor \\frac{\\text{MaxRecursiveInlineDepth}}{\\text{RecursionComplexity}(f)} \\right\\rfloor 复杂度通过函数CFG的环路数和状态数计算 41. loop_unswitch.cc - 循环不变量外提优化 细化 优化目的:\n循环不变量外提以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 不变量条件检测: 循环条件表达式$cond$可外提当满足:\n\\forall v \\in \\text{Var}(cond),\\quad \\text{Def}(v) \\cap \\text{LoopBody} = \\emptyset \\quad \\land \\quad \\text{VolatileAccess}(cond) = \\emptyset 代码克隆代价: 外提决策需满足:\n\\text{CloneCost} = \\sum_{b \\in \\text{CopiedBlocks}} \\text{Cycle}(b) \\times \\text{Iterations} \u0026lt; \\text{BranchMissPenalty} \\times \\text{PredictMissRate} 42. instruction_combine.cc - 指令组合优化 细化 优化目的:\n指令组合以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 代数化简规则:\n位运算吸收律: (x \\ll a) \\ll b \\Rightarrow x \\ll (a+b) \\quad \\text{当且仅当} \\quad a+b \u0026lt; \\text{BitWidth}(x) 常量折叠边界: \\text{Foldable}(expr) \\iff \\forall v \\in \\text{Var}(expr),\\ \\text{ValueRange}(v) \\text{ 在编译时可确定} 窥孔优化模式:\n; 乘加融合优化示例: %t1 = mul i32 %a, 3 %t2 = add i32 %t1, 5 ; 优化后: %t2 = mul add i32 %a, 5, 3 ; 假设目标架构支持乘加指令 43. const_propagate.cc - 常量传播优化 细化 优化目的:\n常量传播以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 数据流方程:\n到达定值分析: 对基本块$B$的入口/出口定值集合满足: IN[B] = \\bigcup_{P \\in pred(B)} OUT[P] \\\\ OUT[B] = GEN[B] \\cup (IN[B] \\setminus KILL[B]) 其中$GEN[B]$为块内生成常量,$KILL[B]$为覆盖的变量定义 条件常量传播:\n; 条件分支常量折叠示例: %cond = icmp eq i32 %x, 42 br i1 %cond, label %true, label %false ; 若%x在数据流分析中恒等于42, 可优化为: br label %true 44. cse.cc - 公共子表达式消除 细化 优化目的:\n公共子表达式消除以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 表达式哈希模型:\n规范化规则: 表达式的规范形式满足: \\text{Hash}(e) = \\text{Opcode}(e) \\oplus \\bigoplus_{i} \\text{Hash}(e.operand_i) 交换律运算需额外排序操作数 (如按变量名排序交换律操作数) 冗余检测矩阵: 表达式$e$在基本块$B$中冗余当满足:\n\\exists e\u0026#39; \\in \\text{ExprTable}[B],\\quad \\text{Hash}(e) = \\text{Hash}(e\u0026#39;) \\land \\text{Dominates}(def(e\u0026#39;), use(e)) 45. dce.cc - 死代码消除优化 细化 优化目的:\n死代码消除以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 副作用分析:\n活跃操作检测: 指令$I$可删除当满足: \\text{SideEffect}(I) = \\emptyset \\quad \\land \\quad \\forall v \\in def(I),\\ \\text{UseCount}(v) = 0 控制依赖约束: 包含关键副作用的指令(如系统调用)需满足:\n\\text{Preserve}(I) \\iff \\text{MayAffectControlFlow}(I) \\lor \\text{VolatileAccess}(I) 46. licm.cc - 循环不变代码外提优化 细化 优化目的:\n循环不变代码外提以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 循环不变式检测:\n操作数不变性条件: 表达式 ( e ) 可外提当满足: [ \\forall v \\in \\text{Operands}(e),\\ \\text{Def}(v) \\cap \\text{LoopBody} = \\emptyset \\ \\land \\ \\text{Value}(v)\\ \\text{在循环迭代中恒定} ] 若操作数是全局变量,需确保循环内无修改该变量的操作。 安全外提约束:\n表达式执行不能有副作用: [ \\text{SideEffect}(e) = \\emptyset \\ \\land \\ \\text{ExceptionFree}(e) ] 若循环可能不执行(如 while 循环),需插入保护条件: if (loop_condition) { // 外提后的代码 // 原循环体 } 47. loop_fusion.cc - 循环融合优化 细化 优化目的:\n循环融合以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 融合合法性条件:\n数据依赖约束: 循环 ( L_1 ) 和 ( L_2 ) 可融合当满足: [ \\text{Distance}(L_1, L_2) \\geq 0 \\quad \\land \\quad \\text{NoNegativeDependence}(L_1, L_2) ] 对跨迭代依赖(如 L1[i] 依赖 L2[i-1]),需验证依赖关系在融合后仍合法。 资源利用率模型: 融合后的循环需满足: [ \\frac{\\text{CacheFootprint}(L_{\\text{fused}})}{\\text{CacheSize}} \\leq \\theta \\quad (\\theta \\approx 0.7) ]\n若融合导致寄存器压力超过阈值,放弃融合。 48. loop_peeling.cc - 循环剥离优化 细化 优化目的:\n循环剥离以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 首迭代剥离条件: 循环可剥离首个迭代当满足: [ \\exists \\text{IterationSpace}_0,\\quad \\text{IterationSpace}_0 \\text{ 包含特殊条件(如除数非零、指针非空)} ]\n例如: // 原始循环: for (i=0; i\u0026lt;N; i++) { if (i == 0) x = 1; // 首迭代特殊处理 // ... } // 剥离后: if (N \u0026gt; 0) { x = 1; // 剥离的首迭代 for (i=1; i\u0026lt;N; i++) { /* ... */ } } 边界对齐优化: 剥离尾迭代以适配向量化: [ \\text{PeelCount} = \\text{VectorWidth} - (N \\bmod \\text{VectorWidth}) ]\n剥离后剩余迭代数满足 ( N\u0026rsquo; \\bmod \\text{VectorWidth} = 0 )。 49. vectorization.cc - 自动向量化优化 细化 优化目的:\n自动向量化以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 向量化可行性分析:\n数据对齐约束: 内存访问模式需满足: [ \\forall \\text{访问地址} a_i,\\quad a_i \\equiv a_0 + k \\cdot \\text{VectorWidth} \\pmod{\\text{CacheLineSize}} ] 若无法静态确定对齐,需插入动态对齐指令。 循环展开因子: 最优展开因子 ( u ) 由下式确定: [ u = \\arg\\max_{1 \\leq k \\leq U_{\\text{max}}} \\left( \\frac{\\text{IPC}_{\\text{理论}} \\cdot k}{\\text{RegisterPressure}(k)} \\right) ]\n( U_{\\text{max}} ) 由目标架构的寄存器数量限制。 依赖冲突检测: 向量化需满足: [ \\forall i \\neq j,\\quad \\text{Distance}(S_i, S_j) \\geq \\text{VectorWidth} ]\n对跨迭代依赖(如 a[i] = a[i-1] + 1),需进行依赖展开或放弃向量化。 50. loop_tiling.cc - 循环分块优化 细化 优化目的:\n循环分块以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 分块尺寸选择: 最优分块尺寸 $T$ 通过最小化缓存未命中率: [ T = \\sqrt{\\frac{\\text{CacheSize}}{\\text{ElementSize} \\cdot N_{\\text{dim}}}} ]\n多维循环需满足各维度分块乘积不超过缓存容量 数据局部性提升: 分块后数据复用率满足: [ \\text{ReuseRatio} = \\frac{\\text{BlockIterations}}{\\text{MemoryAccesses}} \\geq \\text{ReuseThreshold} ]\n对矩阵乘法等计算密集型循环,分块可提升 L1/L2 缓存命中率 51. tail_call.cc - 尾调用优化 细化 优化目的:\n尾调用优化以提高执行效率和缓存局部性 减少内存访问和计算开销 应用场景:\n高性能计算 科学计算 尾调用识别条件: 函数调用$f(x)$可优化为尾调用当满足: [ \\text{CallSite}(f) \\equiv \\text{ReturnSite}(current) \\quad \\land \\quad \\text{StackFrameReusable}(current, f) ]\n栈帧复用约束: [ \\text{FrameSize}(caller) \\leq \\text{FrameSize}(callee) \\ \\land \\ \\text{ParameterAlignment} \\equiv 0 \\pmod{\\text{WordSize}} ]\n若被调用者栈帧更大,需插入栈调整指令或放弃优化 ","permalink":"https://KDZZZZZZ.github.io/posts/optimizations/","summary":"\u003ch1 id=\"tvm-relay-ir-optimization-methods\"\u003eTVM Relay IR Optimization Methods\u003c/h1\u003e\n\u003ch2 id=\"优化方法概述\"\u003e优化方法概述\u003c/h2\u003e\n\u003cp\u003e本文档详细介绍了TVM Relay IR中实现的各种优化方法。每个优化方法都包含其数学原理、算法实现和实际应用示例。这些优化方法共同构成了TVM的优化体系,旨在提高深度学习模型的执行效率。\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#tvm-relay-ir-optimization-methods\"\u003eTVM Relay IR Optimization Methods\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0\"\u003e优化方法概述\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#table-of-contents\"\u003eTable of Contents\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#1-dead_codecc---%E6%AD%BB%E4%BB%A3%E7%A0%81%E6%B6%88%E9%99%A4-%E7%BB%86%E5%8C%96\"\u003e1. \u003ccode\u003edead_code.cc\u003c/code\u003e - 死代码消除 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#2-eliminate_common_subexprcc---%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4-%E7%BB%86%E5%8C%96\"\u003e2. \u003ccode\u003eeliminate_common_subexpr.cc\u003c/code\u003e - 公共子表达式消除 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#3-fold_constantcc---%E5%B8%B8%E9%87%8F%E6%8A%98%E5%8F%A0-%E7%BB%86%E5%8C%96\"\u003e3. \u003ccode\u003efold_constant.cc\u003c/code\u003e - 常量折叠 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#4-fuse_opscc---%E7%AE%97%E5%AD%90%E8%9E%8D%E5%90%88%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e4. \u003ccode\u003efuse_ops.cc\u003c/code\u003e - 算子融合优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#5-transform_layouth-convert_layoutcc---%E5%B8%83%E5%B1%80%E8%BD%AC%E6%8D%A2-%E7%BB%86%E5%8C%96\"\u003e5. \u003ccode\u003etransform_layout.h\u003c/code\u003e, \u003ccode\u003econvert_layout.cc\u003c/code\u003e - 布局转换 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#6-type_infercc---%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-%E7%BB%86%E5%8C%96\"\u003e6. \u003ccode\u003etype_infer.cc\u003c/code\u003e - 类型推断 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#7-to_a_normal_formcc---a-%E8%8C%83%E5%BC%8F%E8%BD%AC%E6%8D%A2-%E7%BB%86%E5%8C%96\"\u003e7. \u003ccode\u003eto_a_normal_form.cc\u003c/code\u003e - A-范式转换 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#8-to_graph_normal_formcc---%E5%9B%BE%E8%8C%83%E5%BC%8F%E8%BD%AC%E6%8D%A2-%E7%BB%86%E5%8C%96\"\u003e8. \u003ccode\u003eto_graph_normal_form.cc\u003c/code\u003e - 图范式转换 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#9-partial_evalcc---%E9%83%A8%E5%88%86%E6%B1%82%E5%80%BC-%E7%BB%86%E5%8C%96\"\u003e9. \u003ccode\u003epartial_eval.cc\u003c/code\u003e - 部分求值 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#10-loop_partitioncc---%E5%BE%AA%E7%8E%AF%E5%88%86%E5%9D%97%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e10. \u003ccode\u003eloop_partition.cc\u003c/code\u003e - 循环分块优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#11-loop_unrollcc---%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80-%E7%BB%86%E5%8C%96\"\u003e11. \u003ccode\u003eloop_unroll.cc\u003c/code\u003e - 循环展开 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#12-loop_vectorizecc---%E5%BE%AA%E7%8E%AF%E5%90%91%E9%87%8F%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e12. \u003ccode\u003eloop_vectorize.cc\u003c/code\u003e - 循环向量化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#13-memory_promotioncc---%E5%86%85%E5%AD%98%E6%8F%90%E5%8D%87%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e13. \u003ccode\u003ememory_promotion.cc\u003c/code\u003e - 内存提升优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#14-simplify_exprcc---%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e14. \u003ccode\u003esimplify_expr.cc\u003c/code\u003e - 表达式简化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#15-storage_rewritecc---%E5%AD%98%E5%82%A8%E9%87%8D%E5%86%99%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e15. \u003ccode\u003estorage_rewrite.cc\u003c/code\u003e - 存储重写优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#16-parallelizecc---%E5%B9%B6%E8%A1%8C%E5%8C%96%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e16. \u003ccode\u003eparallelize.cc\u003c/code\u003e - 并行化优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#17-memory_alloccc---%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e17. \u003ccode\u003ememory_alloc.cc\u003c/code\u003e - 内存分配优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#18-dataflow_analysiscc---%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90-%E7%BB%86%E5%8C%96\"\u003e18. \u003ccode\u003edataflow_analysis.cc\u003c/code\u003e - 数据流分析 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#19-loop_invariantcc---%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F%E5%A4%96%E6%8F%90-%E7%BB%86%E5%8C%96\"\u003e19. \u003ccode\u003eloop_invariant.cc\u003c/code\u003e - 循环不变式外提 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#20-bound_check_eliminatecc---%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5%E6%B6%88%E9%99%A4-%E7%BB%86%E5%8C%96\"\u003e20. \u003ccode\u003ebound_check_eliminate.cc\u003c/code\u003e - 边界检查消除 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#21-common_subexp_eliminatecc---%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4-%E7%BB%86%E5%8C%96\"\u003e21. \u003ccode\u003ecommon_subexp_eliminate.cc\u003c/code\u003e - 公共子表达式消除 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#22-dead_code_eliminatecc---%E6%AD%BB%E4%BB%A3%E7%A0%81%E6%B6%88%E9%99%A4-%E7%BB%86%E5%8C%96\"\u003e22. \u003ccode\u003edead_code_eliminate.cc\u003c/code\u003e - 死代码消除 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#23-strength_reductioncc---%E5%BC%BA%E5%BA%A6%E6%B6%88%E5%87%8F-%E7%BB%86%E5%8C%96\"\u003e23. \u003ccode\u003estrength_reduction.cc\u003c/code\u003e - 强度消减 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#24-register_allocatecc---%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D-%E7%BB%86%E5%8C%96\"\u003e24. \u003ccode\u003eregister_allocate.cc\u003c/code\u003e - 寄存器分配 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#25-vectorizecc---%E5%90%91%E9%87%8F%E5%8C%96%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e25. \u003ccode\u003evectorize.cc\u003c/code\u003e - 向量化优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#26-loop_unrollcc---%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e26. \u003ccode\u003eloop_unroll.cc\u003c/code\u003e - 循环展开优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#27-inline_expandcc---%E5%86%85%E8%81%94%E5%B1%95%E5%BC%80%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e27. \u003ccode\u003einline_expand.cc\u003c/code\u003e - 内联展开优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#28-const_propagationcc---%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e28. \u003ccode\u003econst_propagation.cc\u003c/code\u003e - 常量传播优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#29-alias_analysiscc---%E5%88%AB%E5%90%8D%E5%88%86%E6%9E%90-%E7%BB%86%E5%8C%96\"\u003e29. \u003ccode\u003ealias_analysis.cc\u003c/code\u003e - 别名分析 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#31-mem2regcc---%E5%86%85%E5%AD%98%E5%88%B0%E5%AF%84%E5%AD%98%E5%99%A8%E6%8F%90%E5%8D%87-%E7%BB%86%E5%8C%96\"\u003e31. \u003ccode\u003emem2reg.cc\u003c/code\u003e - 内存到寄存器提升 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#32-gvncc---%E5%85%A8%E5%B1%80%E5%80%BC%E7%BC%96%E5%8F%B7-%E7%BB%86%E5%8C%96\"\u003e32. \u003ccode\u003egvn.cc\u003c/code\u003e - 全局值编号 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#33-loop_fusioncc---%E5%BE%AA%E7%8E%AF%E8%9E%8D%E5%90%88%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e33. \u003ccode\u003eloop_fusion.cc\u003c/code\u003e - 循环融合优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#34-loop_tilingcc---%E5%BE%AA%E7%8E%AF%E5%88%86%E5%9D%97%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e34. \u003ccode\u003eloop_tiling.cc\u003c/code\u003e - 循环分块优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#35-tail_call_optcc---%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e35. \u003ccode\u003etail_call_opt.cc\u003c/code\u003e - 尾调用优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#36-autovectorizecc---%E8%87%AA%E5%8A%A8%E5%90%91%E9%87%8F%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e36. \u003ccode\u003eautovectorize.cc\u003c/code\u003e - 自动向量化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#37-dead_store_elimcc---%E6%AD%BB%E5%AD%98%E5%82%A8%E6%B6%88%E9%99%A4%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e37. \u003ccode\u003edead_store_elim.cc\u003c/code\u003e - 死存储消除优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#38-strength_reductioncc---%E5%BC%BA%E5%BA%A6%E5%89%8A%E5%87%8F%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e38. \u003ccode\u003estrength_reduction.cc\u003c/code\u003e - 强度削减优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#39-register_alloccc---%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e39. \u003ccode\u003eregister_alloc.cc\u003c/code\u003e - 寄存器分配优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#40-inline_expansioncc---%E5%86%85%E8%81%94%E5%B1%95%E5%BC%80%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e40. \u003ccode\u003einline_expansion.cc\u003c/code\u003e - 内联展开优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#41-loop_unswitchcc---%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F%E5%A4%96%E6%8F%90%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e41. \u003ccode\u003eloop_unswitch.cc\u003c/code\u003e - 循环不变量外提优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#42-instruction_combinecc---%E6%8C%87%E4%BB%A4%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e42. \u003ccode\u003einstruction_combine.cc\u003c/code\u003e - 指令组合优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#43-const_propagatecc---%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e43. \u003ccode\u003econst_propagate.cc\u003c/code\u003e - 常量传播优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#44-csecc---%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4-%E7%BB%86%E5%8C%96\"\u003e44. \u003ccode\u003ecse.cc\u003c/code\u003e - 公共子表达式消除 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#45-dcecc---%E6%AD%BB%E4%BB%A3%E7%A0%81%E6%B6%88%E9%99%A4%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e45. \u003ccode\u003edce.cc\u003c/code\u003e - 死代码消除优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#46-licmcc---%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E4%BB%A3%E7%A0%81%E5%A4%96%E6%8F%90%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e46. \u003ccode\u003elicm.cc\u003c/code\u003e - 循环不变代码外提优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#47-loop_fusioncc---%E5%BE%AA%E7%8E%AF%E8%9E%8D%E5%90%88%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e47. \u003ccode\u003eloop_fusion.cc\u003c/code\u003e - 循环融合优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#48-loop_peelingcc---%E5%BE%AA%E7%8E%AF%E5%89%A5%E7%A6%BB%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e48. \u003ccode\u003eloop_peeling.cc\u003c/code\u003e - 循环剥离优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#49-vectorizationcc---%E8%87%AA%E5%8A%A8%E5%90%91%E9%87%8F%E5%8C%96%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e49. \u003ccode\u003evectorization.cc\u003c/code\u003e - 自动向量化优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#50-loop_tilingcc---%E5%BE%AA%E7%8E%AF%E5%88%86%E5%9D%97%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e50. \u003ccode\u003eloop_tiling.cc\u003c/code\u003e - 循环分块优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#51-tail_callcc---%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96-%E7%BB%86%E5%8C%96\"\u003e51. \u003ccode\u003etail_call.cc\u003c/code\u003e - 尾调用优化 细化\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"1-dead_codecc---死代码消除-细化\"\u003e1. \u003ccode\u003edead_code.cc\u003c/code\u003e - 死代码消除 细化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e优化目的\u003c/strong\u003e:\u003c/p\u003e","title":""}]