<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Oops</title><link>https://KDZZZZZZ.github.io/</link><description>Recent content on Oops</description><generator>Hugo -- 0.143.1</generator><language>en-us</language><lastBuildDate>Tue, 28 Jan 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://KDZZZZZZ.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>TVM Function objects and registration implementation</title><link>https://KDZZZZZZ.github.io/posts/tvm%E4%BB%A3%E7%A0%81%E5%BA%93%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/</link><pubDate>Tue, 28 Jan 2025 00:00:00 +0800</pubDate><guid>https://KDZZZZZZ.github.io/posts/tvm%E4%BB%A3%E7%A0%81%E5%BA%93%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>首先给出TVM中注册自定义函数和调用自定义函数的方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 注册函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>TVM_REGISTER_GLOBAL(&lt;span style="color:#e6db74">&amp;#34;add&amp;#34;&lt;/span>).set_body([](TVMArgs args, TVMRetValue&lt;span style="color:#f92672">*&lt;/span> ret) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> args[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> args[&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>ret &lt;span style="color:#f92672">=&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 调用函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>PackedFunc add &lt;span style="color:#f92672">=&lt;/span> runtime&lt;span style="color:#f92672">::&lt;/span>Registry&lt;span style="color:#f92672">::&lt;/span>Get(&lt;span style="color:#e6db74">&amp;#34;add&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> add(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>); &lt;span style="color:#75715e">// 返回 8
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>TVM实现注册Lambda函数的&lt;code>set_body&lt;/code>函数是一个指向&lt;code>PackedFunc&lt;/code>类型的指针.&lt;/p>
&lt;p>&lt;code>TVM_REGISTER_GLOBAL&lt;/code>的实现如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define REGISTER_GLOBAL(name, func) \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> tvm::runtime::FRegistry::Register(name, tvm::runtime::PackedFunc(func))
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用全局哈希表&lt;code>FRegistry&lt;/code>注册函数。通过宏&lt;code>REGISTER_GLOBAL(&amp;quot;func_name&amp;quot;, MyFunction)&lt;/code>将函数与名称绑定，后续通过&lt;code>GetPackedFunc(&amp;quot;func_name&amp;quot;)&lt;/code>查找.&lt;/p>
&lt;p>使用&lt;code>REGISTER_GLOBAL&lt;/code>宏将函数与名称绑定。这个宏会调用&lt;code>FRegistry::Register&lt;/code>方法，将函数存储到全局哈希表中。&lt;/p>
&lt;p>&lt;code>PackedFunc&lt;/code>类型继承自&lt;code>ObjectRef&lt;/code>基类，实现了运算符重载，又用&lt;code>make_object&lt;/code>函数创建一个&lt;code>PackedFuncSubObj&lt;/code>类型对象，这个对象可以储存可调用对象.&lt;/p>
&lt;p>&lt;code>PackedFuncSubObj&lt;/code>继承自&lt;code>PackedFuncObj&lt;/code>, 这是&lt;code>Object&lt;/code>的子类，&lt;code>Object&lt;/code>实现了引用计数和类型检查，&lt;code>PackedFunObj&lt;/code>对函数指针、参数和返回值指针进行了打包。&lt;/p>
&lt;p>&lt;code>PackedFuncSubObj&lt;/code>类型用&lt;code>std::remove_reference&lt;/code>和&lt;code>std::remove_cv&lt;/code>进行了类型擦除，对&lt;code>const&lt;/code>、&lt;code>volatile&lt;/code>和引用进行去壳，移除我们不需要的特性.&lt;/p>
&lt;p>&lt;code>PackedFuncSubObj&lt;/code>中定义了&lt;code>Extractor&lt;/code>提取器结构，提取器内部的&lt;code>Call&lt;/code>函数是一个指针，用来调用可调用对象。&lt;/p>
&lt;p>接下来解释一下参数和返回值的数据结构。&lt;/p>
&lt;p>分别是&lt;code>TVMArgs&lt;/code>和&lt;code>TVMRetValue&lt;/code>,都使用了联合体&lt;code>TVMValue&lt;/code>对数据进行打包并进行了运算符重载和用于数据传递的基本方法。&lt;/p>
&lt;p>以上所有的实现基本都在&lt;code>include/tvm/runtime/packed_func.h&lt;/code>、&lt;code>include/tvm/runtime/registry.h&lt;/code>和&lt;code>src/runtime/registry.cc&lt;/code>&lt;/p>
&lt;p>&lt;code>Python&lt;/code>封装了&lt;code>ctypes&lt;/code>库，能够通过&lt;code>name&lt;/code>查找全局注册的C++函数并获得函数句柄，调用后得到传回的返回值。
其中对数据类型的包装也是TVM实现任意语言互相调用的关键.&lt;/p></description></item><item><title>TVM代码库解析：Relay层结构与优化Pass</title><link>https://KDZZZZZZ.github.io/posts/tvm%E4%BB%A3%E7%A0%81%E5%BA%93%E8%A7%A3%E6%9E%90relay%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96pass/</link><pubDate>Tue, 28 Jan 2025 00:00:00 +0800</pubDate><guid>https://KDZZZZZZ.github.io/posts/tvm%E4%BB%A3%E7%A0%81%E5%BA%93%E8%A7%A3%E6%9E%90relay%E5%B1%82%E7%BB%93%E6%9E%84%E4%B8%8E%E4%BC%98%E5%8C%96pass/</guid><description>&lt;p>relay层主要由数据结构类(如Constant)和节点类(如ConstantNode)组成。
下面梳理一下他们的继承链。&lt;/p>
&lt;p>ObjectRef → BaseExpr → RelayExpr → Constant&lt;/p>
&lt;p>Object → BaseExprNode → RelayExprNode → ConstantNode&lt;/p>
&lt;blockquote>
&lt;p>源代码库中使用了&lt;code>using ExprNode = tvm::RelayExprNode;&lt;/code>&lt;/p>&lt;/blockquote>
&lt;p>这里先赘述一下上面每个类的的功能：&lt;/p>
&lt;h4 id="1-object-includetvmruntimeobjecth">&lt;strong>(1) &lt;code>Object&lt;/code> (include/tvm/runtime/object.h)&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>TVM &lt;strong>所有对象的基类&lt;/strong>，提供 &lt;strong>引用计数&lt;/strong> 和 &lt;strong>类型系统&lt;/strong> 支持&lt;/li>
&lt;li>实现 &lt;code>RefCount&lt;/code> 机制（通过 &lt;code>use_count&lt;/code> 成员）&lt;/li>
&lt;li>提供 &lt;code>type_index&lt;/code> 用于运行时类型识别（RTTI）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>关键方法&lt;/strong>：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">uint32_t&lt;/span> &lt;span style="color:#a6e22e">type_index&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span>; &lt;span style="color:#75715e">// 类型标识
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">IncRef&lt;/span>(); &lt;span style="color:#75715e">// 增加引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">DecRef&lt;/span>(); &lt;span style="color:#75715e">// 减少引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="2-objectref-includetvmruntimeobjecth">&lt;strong>(2) &lt;code>ObjectRef&lt;/code> (include/tvm/runtime/object.h)&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>所有 &lt;strong>对象引用&lt;/strong> 的基类模板（如 &lt;code>Constant&lt;/code> 本质是 &lt;code>ObjectRef&amp;lt;ConstantNode&amp;gt;&lt;/code>）&lt;/li>
&lt;li>通过智能指针 (&lt;code>ObjectPtr&lt;/code>) &lt;strong>管理 Object 子类的生命周期&lt;/strong>&lt;/li>
&lt;li>提供 &lt;strong>类型安全转换接口&lt;/strong>（如 &lt;code>as&amp;lt;T&amp;gt;()&lt;/code>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>关键行为&lt;/strong>：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">*&lt;/span> as() &lt;span style="color:#66d9ef">const&lt;/span>; &lt;span style="color:#75715e">// 安全类型转换
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#a6e22e">bool&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span>; &lt;span style="color:#75715e">// 检查是否非空
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="3-baseexprnode-includetvmirexprh">&lt;strong>(3) &lt;code>BaseExprNode&lt;/code> (include/tvm/ir/expr.h)&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>继承关系&lt;/strong>：&lt;code>Object&lt;/code> → &lt;code>BaseExprNode&lt;/code>&lt;/li>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>所有 &lt;strong>表达式节点&lt;/strong> 的抽象基类&lt;/li>
&lt;li>定义表达式通用接口：
&lt;ul>
&lt;li>数据类型 (&lt;code>dtype&lt;/code>)&lt;/li>
&lt;li>源码位置 (&lt;code>span&lt;/code>)&lt;/li>
&lt;li>虚函数 &lt;code>SEqualReduce&lt;/code>（用于结构相等性比较）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>关键成员&lt;/strong>：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>runtime&lt;span style="color:#f92672">::&lt;/span>DataType dtype; &lt;span style="color:#75715e">// 数据类型（如 float32）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Span span; &lt;span style="color:#75715e">// 源码位置信息（用于调试）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="4-baseexpr-includetvmirexprh">&lt;strong>(4) &lt;code>BaseExpr&lt;/code> (include/tvm/ir/expr.h)&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>继承关系&lt;/strong>：&lt;code>ObjectRef&lt;/code> → &lt;code>BaseExpr&lt;/code>&lt;/li>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>所有 &lt;strong>表达式引用&lt;/strong> 的基类（如 &lt;code>Constant&lt;/code>、&lt;code>Var&lt;/code> 等）&lt;/li>
&lt;li>提供对 &lt;code>BaseExprNode&lt;/code> 的通用访问接口&lt;/li>
&lt;li>重载运算符（如 &lt;code>operator==&lt;/code>）实现表达式比较&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="5-relayexprnode-includetvmirexprh">&lt;strong>(5) &lt;code>RelayExprNode&lt;/code> (include/tvm/ir/expr.h)&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>继承关系&lt;/strong>：&lt;code>BaseExprNode&lt;/code> → &lt;code>RelayExprNode&lt;/code>&lt;/li>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>Relay 表达式体系的节点基类&lt;/strong>，定义所有高层计算图节点的通用行为&lt;/li>
&lt;li>存储 Relay 特有的元数据：
&lt;ul>
&lt;li>&lt;strong>类型信息&lt;/strong> (&lt;code>checked_type_&lt;/code>): 类型推断后的结果（如 &lt;code>TensorType(shape=[1,3], dtype=float32)&lt;/code>）&lt;/li>
&lt;li>&lt;strong>源码位置&lt;/strong> (&lt;code>span&lt;/code>): 用于调试和错误定位&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实现 &lt;strong>结构等价性检查&lt;/strong> (&lt;code>SEqualReduce&lt;/code>) 和 &lt;strong>哈希生成&lt;/strong> (&lt;code>SHashReduce&lt;/code>) 的虚函数&lt;/li>
&lt;li>支持 &lt;strong>递归遍历子节点&lt;/strong> 的接口（用于优化 Pass 或分析）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>关键成员&lt;/strong>：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">mutable&lt;/span> Type checked_type_; &lt;span style="color:#75715e">// 类型推断结果（可缓存）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Span span; &lt;span style="color:#75715e">// 源码位置信息
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;strong>典型子类&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>ConstantNode&lt;/code>（常量）&lt;/li>
&lt;li>&lt;code>VarNode&lt;/code>（变量）&lt;/li>
&lt;li>&lt;code>CallNode&lt;/code>（函数调用）&lt;/li>
&lt;li>&lt;code>FunctionNode&lt;/code>（函数定义）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="6-relayexpr-includetvmirexprh">&lt;strong>(6) &lt;code>RelayExpr&lt;/code> (include/tvm/ir/expr.h)&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>继承关系&lt;/strong>：&lt;code>BaseExpr&lt;/code> → &lt;code>RelayExpr&lt;/code>&lt;/li>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>通过&lt;code>TVM_DEFINE_OBJECT_REF_METHODS&lt;/code>宏定义了对象引用管理、类型转换和节点访问的功能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="7-constantnode-includetvmrelayexprh">&lt;strong>(7) &lt;code>ConstantNode&lt;/code> (include/tvm/relay/expr.h)&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>继承关系&lt;/strong>：&lt;code>RelayExprNode&lt;/code> → &lt;code>ConstantNode&lt;/code>&lt;/li>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>存储常量数据的节点&lt;/strong>（具体实现）&lt;/li>
&lt;li>持有 &lt;code>runtime::NDArray&lt;/code> 表示常量值&lt;/li>
&lt;li>实现 &lt;code>SEqualReduce&lt;/code> 比较常量值是否相等&lt;/li>
&lt;li>实现 &lt;code>SHashReduce&lt;/code> 生成哈希值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>关键成员&lt;/strong>：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>runtime&lt;span style="color:#f92672">::&lt;/span>NDArray data; &lt;span style="color:#75715e">// 常量数据（可以是标量或张量）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="8-constant-includetvmrelayexprh">&lt;strong>(8) &lt;code>Constant&lt;/code> (include/tvm/relay/expr.h)&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>继承关系&lt;/strong>：&lt;code>RelayExpr&lt;/code> → &lt;code>Constant&lt;/code>&lt;/li>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>用户直接使用的常量包装类&lt;/strong>&lt;/li>
&lt;li>构造函数封装 &lt;code>ConstantNode&lt;/code> 的创建&lt;/li>
&lt;li>提供对 &lt;code>data&lt;/code> 的安全访问方法&lt;/li>
&lt;li>示例用法：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>NDArray arr &lt;span style="color:#f92672">=&lt;/span> ...;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Constant c &lt;span style="color:#f92672">=&lt;/span> Constant(arr); &lt;span style="color:#75715e">// 创建常量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Expr expr &lt;span style="color:#f92672">=&lt;/span> c; &lt;span style="color:#75715e">// 可隐式转换为基类
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>有了对基类的功能认识，我们只需要继续了解类似&lt;code>Constant&lt;/code>和&lt;code>ConstantNode&lt;/code>类的其他主要类实现。&lt;/p></description></item><item><title>Welcome to My Blog</title><link>https://KDZZZZZZ.github.io/posts/welcome-to-my-blog/</link><pubDate>Sun, 29 Dec 2024 00:00:00 +0000</pubDate><guid>https://KDZZZZZZ.github.io/posts/welcome-to-my-blog/</guid><description>&lt;h2 id="welcome">Welcome!&lt;/h2>
&lt;p>Hello everyone! This is my new blog built with Hugo. I&amp;rsquo;m excited to share my thoughts and experiences here.&lt;/p>
&lt;h3 id="what-to-expect">What to Expect&lt;/h3>
&lt;p>In this blog, I plan to write about:&lt;/p>
&lt;ol>
&lt;li>Technology and Programming&lt;/li>
&lt;li>Learning experiences&lt;/li>
&lt;li>Personal growth&lt;/li>
&lt;li>Interesting projects&lt;/li>
&lt;/ol>
&lt;h3 id="why-i-started-blogging">Why I Started Blogging&lt;/h3>
&lt;p>I believe writing is a great way to:&lt;/p>
&lt;ul>
&lt;li>Organize thoughts&lt;/li>
&lt;li>Share knowledge&lt;/li>
&lt;li>Document learning journey&lt;/li>
&lt;li>Connect with like-minded people&lt;/li>
&lt;/ul>
&lt;p>Stay tuned for more posts!&lt;/p></description></item><item><title>我的第一篇博客</title><link>https://KDZZZZZZ.github.io/posts/my-first-post/</link><pubDate>Sat, 28 Dec 2024 20:41:44 +0800</pubDate><guid>https://KDZZZZZZ.github.io/posts/my-first-post/</guid><description>&lt;h1 id="欢迎来到我的博客">欢迎来到我的博客！&lt;/h1>
&lt;p>这是我用 Hugo 搭建的新博客的第一篇文章。我很高兴能在这里开始分享我的想法和经历。&lt;/p>
&lt;h2 id="期待">期待&lt;/h2>
&lt;p>我会在这里写一些我感兴趣的话题。敬请期待更多内容！&lt;/p></description></item><item><title>About Me</title><link>https://KDZZZZZZ.github.io/about/</link><pubDate>Sat, 28 Dec 2024 00:00:00 +0000</pubDate><guid>https://KDZZZZZZ.github.io/about/</guid><description>&lt;p>Oops，本科就读于杭州电子科技大学CS系28级，渴望灵感之风的吹拂也希望夯实工程能力。&lt;/p>
&lt;h2 id="虚度的时间">虚度的时间&lt;/h2>
&lt;p>探索了CS的必修四件套，go后端入门，NLP算法基础，以及一些电子元件的理论知识。还有一些比赛、外包项目。&lt;/p>
&lt;h2 id="痛定思痛">痛定思痛&lt;/h2>
&lt;p>接下来我将继续MLSys方向，同时分享一些ML和DL算法和论文复现。或许还有一些微调RAG提示词工程的笔记。靡不有初，鲜克有终。&lt;/p>
&lt;h2 id="关于博客">关于博客&lt;/h2>
&lt;p>理论会尽力严谨，如果有教程会尽力细致，如果有随笔会尽量随便。&lt;/p>
&lt;ul>
&lt;li>GitHub: &lt;a href="https://github.com/KDZZZZZZ">KDZZZZZZ&lt;/a>&lt;/li>
&lt;li>Email: &lt;a href="mailto:2112335382@qq.com">QQ邮箱&lt;/a>&lt;/li>
&lt;li>bilibili: &lt;a href="https://space.bilibili.com/1938413314?spm_id_from=333.1007.0.0">在B站考研&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>会赢的，对吧&lt;/p></description></item><item><title>Hello World</title><link>https://KDZZZZZZ.github.io/posts/hello-world/</link><pubDate>Sat, 28 Dec 2024 00:00:00 +0000</pubDate><guid>https://KDZZZZZZ.github.io/posts/hello-world/</guid><description>&lt;h2 id="hello-world">Hello, World!&lt;/h2>
&lt;p>This is my first blog post. Here, I&amp;rsquo;ll share some interesting tech insights and life experiences.&lt;/p>
&lt;h3 id="why-start-a-blog">Why Start a Blog?&lt;/h3>
&lt;p>Blogging helps me:&lt;/p>
&lt;ol>
&lt;li>Document my learning journey&lt;/li>
&lt;li>Share technical insights&lt;/li>
&lt;li>Connect with like-minded people&lt;/li>
&lt;/ol>
&lt;h3 id="future-plans">Future Plans&lt;/h3>
&lt;p>I plan to write about:&lt;/p>
&lt;ul>
&lt;li>Programming techniques&lt;/li>
&lt;li>Learning experiences&lt;/li>
&lt;li>Life reflections&lt;/li>
&lt;/ul>
&lt;p>Stay tuned!&lt;/p></description></item></channel></rss>